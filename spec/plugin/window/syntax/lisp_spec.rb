# frozen_string_literal: true

require 'spec_helper'
require_relative 'setup_syntax_testing_shared_context'

describe 'esearch window context syntax', :window do
  include Helpers::FileSystem
  include Helpers::WindowSyntaxContext

  describe 'generic' do
    # blank line is kept intentionally to know whether the last verified line
    # corrupts LineNr virtual UI or not

    let(:source_file_content) do
      <<~SOURCE
        < find-method pprint-indent <= find-package pprint-linear = find-restart
        pprint-logical-block > find-symbol pprint-newline >= finish-output pprint-pop -
        first pprint-tab / fixnum pprint-tabular /= flet prin1 // float prin1-to-string
        /// float-digits princ * floating-point-inexact princ-to-string **
        floating-point-invalid-operation print *** floating-point-overflow
        print-not-readable + floating-point-underflow print-not-readable-object ++
        floatp print-object +++ float-precision print-unreadable-object 1- float-radix
        probe-file 1+ float-sign proclaim abort floor prog abs fmakunbound prog* access
        force-output prog1 acons format prog2 acos formatter progn acosh fourth
        program-error add-method fresh-line progv adjoin fround provide
        adjustable-array-p ftruncate psetf adjust-array ftype psetq allocate-instance
        funcall push alpha-char-p function pushnew alphanumericp function-keywords
        putprop and function-lambda-expression quote append functionp random apply gbitp
        random-state applyhook gcd random-state-p apropos generic-function rassoc
        apropos-list gensym rassoc-if aref gentemp rassoc-if-not arithmetic-error get
        ratio arithmetic-error-operands get-decoded-time rational
        arithmetic-error-operation get-dispatch-macro-character rationalize array getf
        rationalp array-dimension gethash read array-dimension-limit
        get-internal-real-time read-byte array-dimensions get-internal-run-time
        read-char array-displacement get-macro-character read-char-no-hang
        array-element-type get-output-stream-string read-delimited-list
        array-has-fill-pointer-p get-properties reader-error array-in-bounds-p
        get-setf-expansion read-eval-print arrayp get-setf-method read-from-string
        array-rank get-universal-time read-line array-rank-limit go
        read-preserving-whitespace array-row-major-index graphic-char-p read-sequence
        array-total-size handler-bind readtable array-total-size-limit handler-case
        readtable-case ash hash-table readtablep asin hash-table-count real asinh
        hash-table-p realp assert hash-table-rehash-size realpart assoc
        hash-table-rehash-threshold reduce assoc-if hash-table-size
        reinitialize-instance assoc-if-not hash-table-test rem atan host-namestring remf
        atanh identity remhash atom if remove base-char if-exists remove-duplicates
        base-string ignorable remove-if bignum ignore remove-if-not bit ignore-errors
        remove-method bit-and imagpart remprop bit-andc1 import rename-file bit-andc2
        incf rename-package bit-eqv initialize-instance replace bit-ior inline require
        bit-nand in-package rest bit-nor in-package restart bit-not input-stream-p
        restart-bind bit-orc1 inspect restart-case bit-orc2 int-char restart-name
        bit-vector integer return bit-vector-p integer-decode-float return-from bit-xor
        integer-length revappend block integerp reverse boole interactive-stream-p room
        boole-1 intern rotatef boole-2 internal-time-units-per-second round boolean
        intersection row-major-aref boole-and invalid-method-error rplaca boole-andc1
        invoke-debugger rplacd boole-andc2 invoke-restart safety boole-c1
        invoke-restart-interactively satisfies boole-c2 isqrt sbit boole-clr keyword
        scale-float boole-eqv keywordp schar boole-ior labels search boole-nand lambda
        second boole-nor lambda-list-keywords sequence boole-orc1
        lambda-parameters-limit serious-condition boole-orc2 last set boole-set lcm
        set-char-bit boole-xor ldb set-difference both-case-p ldb-test
        set-dispatch-macro-character boundp ldiff set-exclusive-or break
        least-negative-double-float setf broadcast-stream least-negative-long-float
        set-macro-character broadcast-stream-streams
        least-negative-normalized-double-float set-pprint-dispatch built-in-class
        least-negative-normalized-long-float setq butlast
        least-negative-normalized-short-float set-syntax-from-char byte
        least-negative-normalized-single-float seventh byte-position
        least-negative-short-float shadow byte-size least-negative-single-float
        shadowing-import call-arguments-limit least-positive-double-float
        shared-initialize call-method least-positive-long-float shiftf call-next-method
        least-positive-normalized-double-float short-float capitalize
        least-positive-normalized-long-float short-float-epsilon car
        least-positive-normalized-short-float short-float-negative-epsilon case
        least-positive-normalized-single-float short-site-name catch
        least-positive-short-float signal ccase least-positive-single-float signed-byte
        cdr length signum ceiling let simple-array cell-error let* simple-base-string
        cell-error-name lisp simple-bit-vector cerror lisp-implementation-type
        simple-bit-vector-p change-class lisp-implementation-version simple-condition
        list char simple-condition-format-arguments char< list*
        simple-condition-format-control char<= list-all-packages simple-error char=
        listen simple-string char> list-length simple-string-p char>= listp
        simple-type-error char/= load simple-vector character
        load-logical-pathname-translations simple-vector-p characterp load-time-value
        simple-warning char-bit locally sin char-bits log single-flaot-epsilon
        char-bits-limit logand single-float char-code logandc1 single-float-epsilon
        char-code-limit logandc2 single-float-negative-epsilon char-control-bit logbitp
        sinh char-downcase logcount sixth char-equal logeqv sleep char-font
        logical-pathname slot-boundp char-font-limit logical-pathname-translations
        slot-exists-p char-greaterp logior slot-makunbound char-hyper-bit lognand
        slot-missing char-int lognor slot-unbound char-lessp lognot slot-value
        char-meta-bit logorc1 software-type char-name logorc2 software-version
        char-not-equal logtest some char-not-greaterp logxor sort char-not-lessp
        long-float space char-super-bit long-float-epsilon special char-upcase
        long-float-negative-epsilon special-form-p check-type long-site-name
        special-operator-p cis loop speed class loop-finish sqrt class-name lower-case-p
        stable-sort class-of machine-instance standard clear-input machine-type
        standard-char clear-output machine-version standard-char-p close macroexpand
        standard-class clrhash macroexpand-1 standard-generic-function code-char
        macroexpand-l standard-method coerce macro-function standard-object commonp
        macrolet step compilation-speed make-array storage-condition compile make-array
        store-value compiled-function make-broadcast-stream stream compiled-function-p
        make-char stream-element-type compile-file make-concatenated-stream stream-error
        compile-file-pathname make-condition stream-error-stream compiler-let
        make-dispatch-macro-character stream-external-format compiler-macro
        make-echo-stream streamp compiler-macro-function make-hash-table streamup
        complement make-instance string complex make-instances-obsolete string< complexp
        make-list string<= compute-applicable-methods make-load-form string=
        compute-restarts make-load-form-saving-slots string> concatenate make-method
        string>= concatenated-stream make-package string/= concatenated-stream-streams
        make-pathname string-capitalize cond make-random-state string-char condition
        make-sequence string-char-p conjugate make-string string-downcase cons
        make-string-input-stream string-equal consp make-string-output-stream
        string-greaterp constantly make-symbol string-left-trim constantp
        make-synonym-stream string-lessp continue make-two-way-stream string-not-equal
        control-error makunbound string-not-greaterp copy-alist map string-not-lessp
        copy-list mapc stringp copy-pprint-dispatch mapcan string-right-strim
        copy-readtable mapcar string-right-trim copy-seq mapcon string-stream
        copy-structure maphash string-trim copy-symbol map-into string-upcase copy-tree
        mapl structure cos maplist structure-class cosh mask-field structure-object
        count max style-warning count-if member sublim count-if-not member-if sublis
        ctypecase member-if-not subseq debug merge subsetp decf merge-pathname subst
        declaim merge-pathnames subst-if declaration method subst-if-not declare
        method-combination substitute decode-float method-combination-error
        substitute-if decode-universal-time method-qualifiers substitute-if-not defclass
        min subtypep defconstant minusp svref defgeneric mismatch sxhash
        define-compiler-macro mod symbol define-condition most-negative-double-float
        symbol-function define-method-combination most-negative-fixnum symbol-macrolet
        define-modify-macro most-negative-long-float symbol-name define-setf-expander
        most-negative-short-float symbolp define-setf-method most-negative-single-float
        symbol-package define-symbol-macro most-positive-double-float symbol-plist
        defmacro most-positive-fixnum symbol-value defmethod most-positive-long-float
        synonym-stream defpackage most-positive-short-float synonym-stream-symbol
        defparameter most-positive-single-float sys defsetf muffle-warning system
        defstruct multiple-value-bind t deftype multiple-value-call tagbody defun
        multiple-value-list tailp defvar multiple-value-prog1 tan delete
        multiple-value-seteq tanh delete-duplicates multiple-value-setq tenth
        delete-file multiple-values-limit terpri delete-if name-char the delete-if-not
        namestring third delete-package nbutlast throw denominator nconc time
        deposit-field next-method-p trace describe nil translate-logical-pathname
        describe-object nintersection translate-pathname destructuring-bind ninth
        tree-equal digit-char no-applicable-method truename digit-char-p no-next-method
        truncase directory not truncate directory-namestring notany two-way-stream
        disassemble notevery two-way-stream-input-stream division-by-zero notinline
        two-way-stream-output-stream do nreconc type do* nreverse typecase
        do-all-symbols nset-difference type-error documentation nset-exclusive-or
        type-error-datum do-exeternal-symbols nstring type-error-expected-type
        do-external-symbols nstring-capitalize type-of dolist nstring-downcase typep
        do-symbols nstring-upcase unbound-slot dotimes nsublis unbound-slot-instance
        double-float nsubst unbound-variable double-float-epsilon nsubst-if
        undefined-function double-float-negative-epsilon nsubst-if-not unexport dpb
        nsubstitute unintern dribble nsubstitute-if union dynamic-extent
        nsubstitute-if-not unless ecase nth unread echo-stream nthcdr unread-char
        echo-stream-input-stream nth-value unsigned-byte echo-stream-output-stream null
        untrace ed number unuse-package eighth numberp unwind-protect elt numerator
        update-instance-for-different-class encode-universal-time nunion
        update-instance-for-redefined-class end-of-file oddp upgraded-array-element-type
        endp open upgraded-complex-part-type enough-namestring open-stream-p
        upper-case-p ensure-directories-exist optimize use-package
        ensure-generic-function or user eq otherwise user-homedir-pathname eql
        output-stream-p use-value equal package values equalp package-error values-list
        error package-error-package variable etypecase package-name vector eval
        package-nicknames vectorp evalhook packagep vector-pop eval-when
        package-shadowing-symbols vector-push evenp package-used-by-list
        vector-push-extend every package-use-list warn exp pairlis warning export
        parse-error when expt parse-integer wild-pathname-p extended-char
        parse-namestring with-accessors fboundp pathname with-compilation-unit fceiling
        pathname-device with-condition-restarts fdefinition pathname-directory
        with-hash-table-iterator ffloor pathname-host with-input-from-string fifth
        pathname-match-p with-open-file file-author pathname-name with-open-stream
        file-error pathnamep with-output-to-string file-error-pathname pathname-type
        with-package-iterator file-length pathname-version with-simple-restart
        file-namestring peek-char with-slots file-position phase with-standard-io-syntax
        file-stream pi write file-string-length plusp write-byte file-write-date pop
        write-char fill position write-line fill-pointer position-if write-sequence find
        position-if-not write-string find-all-symbols pprint write-to-string find-class
        pprint-dispatch yes-or-no-p find-if pprint-exit-if-list-exhausted y-or-n-p
        find-if-not pprint-fill zerop true false float-radix

        "lispString"
        "lispString\\"
        "lispString

        '(lispAtomList1)
        '(lispAtomList2

        'lispAtom1
        '"lispAtom2"
        '"lispAtom3

        ;lispComment1
        ; lispComment2

        #|lispComment3|#
        #| lispComment4 |#
        #|lispComment5
        #| lispComment6

        &optional
        :while

      SOURCE
    end
    let(:source_file) { file(source_file_content, 'main.lisp') }

    include_context 'setup syntax testing'

    # 1. Verification is done in a single example for performance reasons (as
    # vim's +clientserver is too sluggish; it doesn't affect debuggability as
    # the matcher is diffable)
    # 2. Lines that can cause matching across line end (e.g. not terminated strings
    # or comments) are not groupped and scattered across source_file to cause as
    # more potential errors as possible
    it do
      require 'pry'; binding.pry
      is_expected.to have_highligh_aliases(
        region('<')                                    => %w[lispFunc Statement],
        word('find-method')                            => %w[lispFunc Statement],
        word('pprint-indent')                          => %w[lispFunc Statement],
        region('<=')                                   => %w[lispFunc Statement],
        word('find-package')                           => %w[lispFunc Statement],
        word('pprint-linear')                          => %w[lispFunc Statement],
        region('=')                                    => %w[lispFunc Statement],
        word('find-restart')                           => %w[lispFunc Statement],
        word('pprint-logical-block')                   => %w[lispFunc Statement],
        region('>')                                    => %w[lispFunc Statement],
        word('find-symbol')                            => %w[lispFunc Statement],
        word('pprint-newline')                         => %w[lispFunc Statement],
        region('>=')                                   => %w[lispFunc Statement],
        word('finish-output')                          => %w[lispFunc Statement],
        word('pprint-pop')                             => %w[lispFunc Statement],
        region('-')                                    => %w[lispFunc Statement],
        word('first')                                  => %w[lispFunc Statement],
        word('pprint-tab')                             => %w[lispFunc Statement],
        region('/')                                    => %w[lispFunc Statement],
        word('fixnum')                                 => %w[lispFunc Statement],
        word('pprint-tabular')                         => %w[lispFunc Statement],
        region('/=')                                   => %w[lispFunc Statement],
        word('flet')                                   => %w[lispFunc Statement],
        word('prin1')                                  => %w[lispFunc Statement],
        region('//')                                   => %w[lispFunc Statement],
        word('float')                                  => %w[lispFunc Statement],
        word('prin1-to-string')                        => %w[lispFunc Statement],
        region('///')                                  => %w[lispFunc Statement],
        word('float-digits')                           => %w[lispFunc Statement],
        word('princ')                                  => %w[lispFunc Statement],
        word('floating-point-inexact')                 => %w[lispFunc Statement],
        word('princ-to-string')                        => %w[lispFunc Statement],
        word('floating-point-invalid-operation')       => %w[lispFunc Statement],
        word('print')                                  => %w[lispFunc Statement],
        word('floating-point-overflow')                => %w[lispFunc Statement],
        word('print-not-readable')                     => %w[lispFunc Statement],
        region('+')                                    => %w[lispFunc Statement],
        word('floating-point-underflow')               => %w[lispFunc Statement],
        word('print-not-readable-object')              => %w[lispFunc Statement],
        region('++')                                   => %w[lispFunc Statement],
        word('floatp')                                 => %w[lispFunc Statement],
        word('print-object')                           => %w[lispFunc Statement],
        region('+++')                                  => %w[lispFunc Statement],
        word('float-precision')                        => %w[lispFunc Statement],
        word('print-unreadable-object')                => %w[lispFunc Statement],
        region('1-')                                   => %w[lispFunc Statement],
        word('float-radix')                            => %w[lispFunc Statement],
        word('probe-file')                             => %w[lispFunc Statement],
        region('1+')                                   => %w[lispFunc Statement],
        word('float-sign')                             => %w[lispFunc Statement],
        word('proclaim')                               => %w[lispFunc Statement],
        word('abort')                                  => %w[lispFunc Statement],
        word('floor')                                  => %w[lispFunc Statement],
        word('prog')                                   => %w[lispFunc Statement],
        word('abs')                                    => %w[lispFunc Statement],
        word('fmakunbound')                            => %w[lispFunc Statement],
        region('prog\\\\*')                            => %w[lispFunc Statement],
        word('access')                                 => %w[lispFunc Statement],
        word('force-output')                           => %w[lispFunc Statement],
        word('prog1')                                  => %w[lispFunc Statement],
        word('acons')                                  => %w[lispFunc Statement],
        word('format')                                 => %w[lispFunc Statement],
        word('prog2')                                  => %w[lispFunc Statement],
        word('acos')                                   => %w[lispFunc Statement],
        word('formatter')                              => %w[lispFunc Statement],
        word('progn')                                  => %w[lispFunc Statement],
        word('acosh')                                  => %w[lispFunc Statement],
        word('fourth')                                 => %w[lispFunc Statement],
        word('program-error')                          => %w[lispFunc Statement],
        word('add-method')                             => %w[lispFunc Statement],
        word('fresh-line')                             => %w[lispFunc Statement],
        word('progv')                                  => %w[lispFunc Statement],
        word('adjoin')                                 => %w[lispFunc Statement],
        word('fround')                                 => %w[lispFunc Statement],
        word('provide')                                => %w[lispFunc Statement],
        word('adjustable-array-p')                     => %w[lispFunc Statement],
        word('ftruncate')                              => %w[lispFunc Statement],
        word('psetf')                                  => %w[lispFunc Statement],
        word('adjust-array')                           => %w[lispFunc Statement],
        word('ftype')                                  => %w[lispFunc Statement],
        word('psetq')                                  => %w[lispFunc Statement],
        word('allocate-instance')                      => %w[lispFunc Statement],
        word('funcall')                                => %w[lispFunc Statement],
        word('push')                                   => %w[lispFunc Statement],
        word('alpha-char-p')                           => %w[lispFunc Statement],
        word('function')                               => %w[lispFunc Statement],
        word('pushnew')                                => %w[lispFunc Statement],
        word('alphanumericp')                          => %w[lispFunc Statement],
        word('function-keywords')                      => %w[lispFunc Statement],
        word('putprop')                                => %w[lispFunc Statement],
        word('and')                                    => %w[lispFunc Statement],
        word('function-lambda-expression')             => %w[lispFunc Statement],
        word('quote')                                  => %w[lispFunc Statement],
        word('append')                                 => %w[lispFunc Statement],
        word('functionp')                              => %w[lispFunc Statement],
        word('random')                                 => %w[lispFunc Statement],
        word('apply')                                  => %w[lispFunc Statement],
        word('gbitp')                                  => %w[lispFunc Statement],
        word('random-state')                           => %w[lispFunc Statement],
        word('applyhook')                              => %w[lispFunc Statement],
        word('gcd')                                    => %w[lispFunc Statement],
        word('random-state-p')                         => %w[lispFunc Statement],
        word('apropos')                                => %w[lispFunc Statement],
        word('generic-function')                       => %w[lispFunc Statement],
        word('rassoc')                                 => %w[lispFunc Statement],
        word('apropos-list')                           => %w[lispFunc Statement],
        word('gensym')                                 => %w[lispFunc Statement],
        word('rassoc-if')                              => %w[lispFunc Statement],
        word('aref')                                   => %w[lispFunc Statement],
        word('gentemp')                                => %w[lispFunc Statement],
        word('rassoc-if-not')                          => %w[lispFunc Statement],
        word('arithmetic-error')                       => %w[lispFunc Statement],
        word('get')                                    => %w[lispFunc Statement],
        word('ratio')                                  => %w[lispFunc Statement],
        word('arithmetic-error-operands')              => %w[lispFunc Statement],
        word('get-decoded-time')                       => %w[lispFunc Statement],
        word('rational')                               => %w[lispFunc Statement],
        word('arithmetic-error-operation')             => %w[lispFunc Statement],
        word('get-dispatch-macro-character')           => %w[lispFunc Statement],
        word('rationalize')                            => %w[lispFunc Statement],
        word('array')                                  => %w[lispFunc Statement],
        word('getf')                                   => %w[lispFunc Statement],
        word('rationalp')                              => %w[lispFunc Statement],
        word('array-dimension')                        => %w[lispFunc Statement],
        word('gethash')                                => %w[lispFunc Statement],
        word('read')                                   => %w[lispFunc Statement],
        word('array-dimension-limit')                  => %w[lispFunc Statement],
        word('get-internal-real-time')                 => %w[lispFunc Statement],
        word('read-byte')                              => %w[lispFunc Statement],
        word('array-dimensions')                       => %w[lispFunc Statement],
        word('get-internal-run-time')                  => %w[lispFunc Statement],
        word('read-char')                              => %w[lispFunc Statement],
        word('array-displacement')                     => %w[lispFunc Statement],
        word('get-macro-character')                    => %w[lispFunc Statement],
        word('read-char-no-hang')                      => %w[lispFunc Statement],
        word('array-element-type')                     => %w[lispFunc Statement],
        word('get-output-stream-string')               => %w[lispFunc Statement],
        word('read-delimited-list')                    => %w[lispFunc Statement],
        word('array-has-fill-pointer-p')               => %w[lispFunc Statement],
        word('get-properties')                         => %w[lispFunc Statement],
        word('reader-error')                           => %w[lispFunc Statement],
        word('array-in-bounds-p')                      => %w[lispFunc Statement],
        word('get-setf-expansion')                     => %w[lispFunc Statement],
        word('read-eval-print')                        => %w[lispFunc Statement],
        word('arrayp')                                 => %w[lispFunc Statement],
        word('get-setf-method')                        => %w[lispFunc Statement],
        word('read-from-string')                       => %w[lispFunc Statement],
        word('array-rank')                             => %w[lispFunc Statement],
        word('get-universal-time')                     => %w[lispFunc Statement],
        word('read-line')                              => %w[lispFunc Statement],
        word('array-rank-limit')                       => %w[lispFunc Statement],
        word('go')                                     => %w[lispFunc Statement],
        word('read-preserving-whitespace')             => %w[lispFunc Statement],
        word('array-row-major-index')                  => %w[lispFunc Statement],
        word('graphic-char-p')                         => %w[lispFunc Statement],
        word('read-sequence')                          => %w[lispFunc Statement],
        word('array-total-size')                       => %w[lispFunc Statement],
        word('handler-bind')                           => %w[lispFunc Statement],
        word('readtable')                              => %w[lispFunc Statement],
        word('array-total-size-limit')                 => %w[lispFunc Statement],
        word('handler-case')                           => %w[lispFunc Statement],
        word('readtable-case')                         => %w[lispFunc Statement],
        word('ash')                                    => %w[lispFunc Statement],
        word('hash-table')                             => %w[lispFunc Statement],
        word('readtablep')                             => %w[lispFunc Statement],
        word('asin')                                   => %w[lispFunc Statement],
        word('hash-table-count')                       => %w[lispFunc Statement],
        word('real')                                   => %w[lispFunc Statement],
        word('asinh')                                  => %w[lispFunc Statement],
        word('hash-table-p')                           => %w[lispFunc Statement],
        word('realp')                                  => %w[lispFunc Statement],
        word('assert')                                 => %w[lispFunc Statement],
        word('hash-table-rehash-size')                 => %w[lispFunc Statement],
        word('realpart')                               => %w[lispFunc Statement],
        word('assoc')                                  => %w[lispFunc Statement],
        word('hash-table-rehash-threshold')            => %w[lispFunc Statement],
        word('reduce')                                 => %w[lispFunc Statement],
        word('assoc-if')                               => %w[lispFunc Statement],
        word('hash-table-size')                        => %w[lispFunc Statement],
        word('reinitialize-instance')                  => %w[lispFunc Statement],
        word('assoc-if-not')                           => %w[lispFunc Statement],
        word('hash-table-test')                        => %w[lispFunc Statement],
        word('rem')                                    => %w[lispFunc Statement],
        word('atan')                                   => %w[lispFunc Statement],
        word('host-namestring')                        => %w[lispFunc Statement],
        word('remf')                                   => %w[lispFunc Statement],
        word('atanh')                                  => %w[lispFunc Statement],
        word('identity')                               => %w[lispFunc Statement],
        word('remhash')                                => %w[lispFunc Statement],
        word('atom')                                   => %w[lispFunc Statement],
        word('if')                                     => %w[lispFunc Statement],
        word('remove')                                 => %w[lispFunc Statement],
        word('base-char')                              => %w[lispFunc Statement],
        word('if-exists')                              => %w[lispFunc Statement],
        word('remove-duplicates')                      => %w[lispFunc Statement],
        word('base-string')                            => %w[lispFunc Statement],
        word('ignorable')                              => %w[lispFunc Statement],
        word('remove-if')                              => %w[lispFunc Statement],
        word('bignum')                                 => %w[lispFunc Statement],
        word('ignore')                                 => %w[lispFunc Statement],
        word('remove-if-not')                          => %w[lispFunc Statement],
        word('bit')                                    => %w[lispFunc Statement],
        word('ignore-errors')                          => %w[lispFunc Statement],
        word('remove-method')                          => %w[lispFunc Statement],
        word('bit-and')                                => %w[lispFunc Statement],
        word('imagpart')                               => %w[lispFunc Statement],
        word('remprop')                                => %w[lispFunc Statement],
        word('bit-andc1')                              => %w[lispFunc Statement],
        word('import')                                 => %w[lispFunc Statement],
        word('rename-file')                            => %w[lispFunc Statement],
        word('bit-andc2')                              => %w[lispFunc Statement],
        word('incf')                                   => %w[lispFunc Statement],
        word('rename-package')                         => %w[lispFunc Statement],
        word('bit-eqv')                                => %w[lispFunc Statement],
        word('initialize-instance')                    => %w[lispFunc Statement],
        word('replace')                                => %w[lispFunc Statement],
        word('bit-ior')                                => %w[lispFunc Statement],
        word('inline')                                 => %w[lispFunc Statement],
        word('require')                                => %w[lispFunc Statement],
        word('bit-nand')                               => %w[lispFunc Statement],
        word('in-package')                             => %w[lispFunc Statement],
        word('rest')                                   => %w[lispFunc Statement],
        word('bit-nor')                                => %w[lispFunc Statement],
        word('in-package')                             => %w[lispFunc Statement],
        word('restart')                                => %w[lispFunc Statement],
        word('bit-not')                                => %w[lispFunc Statement],
        word('input-stream-p')                         => %w[lispFunc Statement],
        word('restart-bind')                           => %w[lispFunc Statement],
        word('bit-orc1')                               => %w[lispFunc Statement],
        word('inspect')                                => %w[lispFunc Statement],
        word('restart-case')                           => %w[lispFunc Statement],
        word('bit-orc2')                               => %w[lispFunc Statement],
        word('int-char')                               => %w[lispFunc Statement],
        word('restart-name')                           => %w[lispFunc Statement],
        word('bit-vector')                             => %w[lispFunc Statement],
        word('integer')                                => %w[lispFunc Statement],
        word('return')                                 => %w[lispFunc Statement],
        word('bit-vector-p')                           => %w[lispFunc Statement],
        word('integer-decode-float')                   => %w[lispFunc Statement],
        word('return-from')                            => %w[lispFunc Statement],
        word('bit-xor')                                => %w[lispFunc Statement],
        word('integer-length')                         => %w[lispFunc Statement],
        word('revappend')                              => %w[lispFunc Statement],
        word('block')                                  => %w[lispFunc Statement],
        word('integerp')                               => %w[lispFunc Statement],
        word('reverse')                                => %w[lispFunc Statement],
        word('boole')                                  => %w[lispFunc Statement],
        word('interactive-stream-p')                   => %w[lispFunc Statement],
        word('room')                                   => %w[lispFunc Statement],
        word('boole-1')                                => %w[lispFunc Statement],
        word('intern')                                 => %w[lispFunc Statement],
        word('rotatef')                                => %w[lispFunc Statement],
        word('boole-2')                                => %w[lispFunc Statement],
        word('internal-time-units-per-second')         => %w[lispFunc Statement],
        word('round')                                  => %w[lispFunc Statement],
        word('boolean')                                => %w[lispFunc Statement],
        word('intersection')                           => %w[lispFunc Statement],
        word('row-major-aref')                         => %w[lispFunc Statement],
        word('boole-and')                              => %w[lispFunc Statement],
        word('invalid-method-error')                   => %w[lispFunc Statement],
        word('rplaca')                                 => %w[lispFunc Statement],
        word('boole-andc1')                            => %w[lispFunc Statement],
        word('invoke-debugger')                        => %w[lispFunc Statement],
        word('rplacd')                                 => %w[lispFunc Statement],
        word('boole-andc2')                            => %w[lispFunc Statement],
        word('invoke-restart')                         => %w[lispFunc Statement],
        word('safety')                                 => %w[lispFunc Statement],
        word('boole-c1')                               => %w[lispFunc Statement],
        word('invoke-restart-interactively')           => %w[lispFunc Statement],
        word('satisfies')                              => %w[lispFunc Statement],
        word('boole-c2')                               => %w[lispFunc Statement],
        word('isqrt')                                  => %w[lispFunc Statement],
        word('sbit')                                   => %w[lispFunc Statement],
        word('boole-clr')                              => %w[lispFunc Statement],
        word('keyword')                                => %w[lispFunc Statement],
        word('scale-float')                            => %w[lispFunc Statement],
        word('boole-eqv')                              => %w[lispFunc Statement],
        word('keywordp')                               => %w[lispFunc Statement],
        word('schar')                                  => %w[lispFunc Statement],
        word('boole-ior')                              => %w[lispFunc Statement],
        word('labels')                                 => %w[lispFunc Statement],
        word('search')                                 => %w[lispFunc Statement],
        word('boole-nand')                             => %w[lispFunc Statement],
        word('lambda')                                 => %w[lispFunc Statement],
        word('second')                                 => %w[lispFunc Statement],
        word('boole-nor')                              => %w[lispFunc Statement],
        word('lambda-list-keywords')                   => %w[lispFunc Statement],
        word('sequence')                               => %w[lispFunc Statement],
        word('boole-orc1')                             => %w[lispFunc Statement],
        word('lambda-parameters-limit')                => %w[lispFunc Statement],
        word('serious-condition')                      => %w[lispFunc Statement],
        word('boole-orc2')                             => %w[lispFunc Statement],
        word('last')                                   => %w[lispFunc Statement],
        word('set')                                    => %w[lispFunc Statement],
        word('boole-set')                              => %w[lispFunc Statement],
        word('lcm')                                    => %w[lispFunc Statement],
        word('set-char-bit')                           => %w[lispFunc Statement],
        word('boole-xor')                              => %w[lispFunc Statement],
        word('ldb')                                    => %w[lispFunc Statement],
        word('set-difference')                         => %w[lispFunc Statement],
        word('both-case-p')                            => %w[lispFunc Statement],
        word('ldb-test')                               => %w[lispFunc Statement],
        word('set-dispatch-macro-character')           => %w[lispFunc Statement],
        word('boundp')                                 => %w[lispFunc Statement],
        word('ldiff')                                  => %w[lispFunc Statement],
        word('set-exclusive-or')                       => %w[lispFunc Statement],
        word('break')                                  => %w[lispFunc Statement],
        word('least-negative-double-float')            => %w[lispFunc Statement],
        word('setf')                                   => %w[lispFunc Statement],
        word('broadcast-stream')                       => %w[lispFunc Statement],
        word('least-negative-long-float')              => %w[lispFunc Statement],
        word('set-macro-character')                    => %w[lispFunc Statement],
        word('broadcast-stream-streams')               => %w[lispFunc Statement],
        word('least-negative-normalized-double-float') => %w[lispFunc Statement],
        word('set-pprint-dispatch')                    => %w[lispFunc Statement],
        word('built-in-class')                         => %w[lispFunc Statement],
        word('least-negative-normalized-long-float')   => %w[lispFunc Statement],
        word('setq')                                   => %w[lispFunc Statement],
        word('butlast')                                => %w[lispFunc Statement],
        word('least-negative-normalized-short-float')  => %w[lispFunc Statement],
        word('set-syntax-from-char')                   => %w[lispFunc Statement],
        word('byte')                                   => %w[lispFunc Statement],
        word('least-negative-normalized-single-float') => %w[lispFunc Statement],
        word('seventh')                                => %w[lispFunc Statement],
        word('byte-position')                          => %w[lispFunc Statement],
        word('least-negative-short-float')             => %w[lispFunc Statement],
        word('shadow')                                 => %w[lispFunc Statement],
        word('byte-size')                              => %w[lispFunc Statement],
        word('least-negative-single-float')            => %w[lispFunc Statement],
        word('shadowing-import')                       => %w[lispFunc Statement],
        word('call-arguments-limit')                   => %w[lispFunc Statement],
        word('least-positive-double-float')            => %w[lispFunc Statement],
        word('shared-initialize')                      => %w[lispFunc Statement],
        word('call-method')                            => %w[lispFunc Statement],
        word('least-positive-long-float')              => %w[lispFunc Statement],
        word('shiftf')                                 => %w[lispFunc Statement],
        word('call-next-method')                       => %w[lispFunc Statement],
        word('least-positive-normalized-double-float') => %w[lispFunc Statement],
        word('short-float')                            => %w[lispFunc Statement],
        word('capitalize')                             => %w[lispFunc Statement],
        word('least-positive-normalized-long-float')   => %w[lispFunc Statement],
        word('short-float-epsilon')                    => %w[lispFunc Statement],
        word('car')                                    => %w[lispFunc Statement],
        word('least-positive-normalized-short-float')  => %w[lispFunc Statement],
        word('short-float-negative-epsilon')           => %w[lispFunc Statement],
        word('case')                                   => %w[lispFunc Statement],
        word('least-positive-normalized-single-float') => %w[lispFunc Statement],
        word('short-site-name')                        => %w[lispFunc Statement],
        word('catch')                                  => %w[lispFunc Statement],
        word('least-positive-short-float')             => %w[lispFunc Statement],
        word('signal')                                 => %w[lispFunc Statement],
        word('ccase')                                  => %w[lispFunc Statement],
        word('least-positive-single-float')            => %w[lispFunc Statement],
        word('signed-byte')                            => %w[lispFunc Statement],
        word('cdr')                                    => %w[lispFunc Statement],
        word('length')                                 => %w[lispFunc Statement],
        word('signum')                                 => %w[lispFunc Statement],
        word('ceiling')                                => %w[lispFunc Statement],
        word('let')                                    => %w[lispFunc Statement],
        word('simple-array')                           => %w[lispFunc Statement],
        word('cell-error')                             => %w[lispFunc Statement],
        region('let\\\\*')                             => %w[lispFunc Statement],
        word('simple-base-string')                     => %w[lispFunc Statement],
        word('cell-error-name')                        => %w[lispFunc Statement],
        word('lisp')                                   => %w[lispFunc Statement],
        word('simple-bit-vector')                      => %w[lispFunc Statement],
        word('cerror')                                 => %w[lispFunc Statement],
        word('lisp-implementation-type')               => %w[lispFunc Statement],
        word('simple-bit-vector-p')                    => %w[lispFunc Statement],
        word('change-class')                           => %w[lispFunc Statement],
        word('lisp-implementation-version')            => %w[lispFunc Statement],
        word('simple-condition')                       => %w[lispFunc Statement],
        word('char')                                   => %w[lispFunc Statement],
        word('list')                                   => %w[lispFunc Statement],
        word('simple-condition-format-arguments')      => %w[lispFunc Statement],
        region('char<')                                => %w[lispFunc Statement],
        region('list\\\\*')                            => %w[lispFunc Statement],
        word('simple-condition-format-control')        => %w[lispFunc Statement],
        region('char<=')                               => %w[lispFunc Statement],
        word('list-all-packages')                      => %w[lispFunc Statement],
        word('simple-error')                           => %w[lispFunc Statement],
        region('char=')                                => %w[lispFunc Statement],
        word('listen')                                 => %w[lispFunc Statement],
        word('simple-string')                          => %w[lispFunc Statement],
        region('char>')                                => %w[lispFunc Statement],
        word('list-length')                            => %w[lispFunc Statement],
        word('simple-string-p')                        => %w[lispFunc Statement],
        region('char>=')                               => %w[lispFunc Statement],
        word('listp')                                  => %w[lispFunc Statement],
        word('simple-type-error')                      => %w[lispFunc Statement],
        region('char/=')                               => %w[lispFunc Statement],
        word('load')                                   => %w[lispFunc Statement],
        word('simple-vector')                          => %w[lispFunc Statement],
        word('character')                              => %w[lispFunc Statement],
        word('load-logical-pathname-translations')     => %w[lispFunc Statement],
        word('simple-vector-p')                        => %w[lispFunc Statement],
        word('characterp')                             => %w[lispFunc Statement],
        word('load-time-value')                        => %w[lispFunc Statement],
        word('simple-warning')                         => %w[lispFunc Statement],
        word('char-bit')                               => %w[lispFunc Statement],
        word('locally')                                => %w[lispFunc Statement],
        word('sin')                                    => %w[lispFunc Statement],
        word('char-bits')                              => %w[lispFunc Statement],
        word('log')                                    => %w[lispFunc Statement],
        word('single-flaot-epsilon')                   => %w[lispFunc Statement],
        word('char-bits-limit')                        => %w[lispFunc Statement],
        word('logand')                                 => %w[lispFunc Statement],
        word('single-float')                           => %w[lispFunc Statement],
        word('char-code')                              => %w[lispFunc Statement],
        word('logandc1')                               => %w[lispFunc Statement],
        word('single-float-epsilon')                   => %w[lispFunc Statement],
        word('char-code-limit')                        => %w[lispFunc Statement],
        word('logandc2')                               => %w[lispFunc Statement],
        word('single-float-negative-epsilon')          => %w[lispFunc Statement],
        word('char-control-bit')                       => %w[lispFunc Statement],
        word('logbitp')                                => %w[lispFunc Statement],
        word('sinh')                                   => %w[lispFunc Statement],
        word('char-downcase')                          => %w[lispFunc Statement],
        word('logcount')                               => %w[lispFunc Statement],
        word('sixth')                                  => %w[lispFunc Statement],
        word('char-equal')                             => %w[lispFunc Statement],
        word('logeqv')                                 => %w[lispFunc Statement],
        word('sleep')                                  => %w[lispFunc Statement],
        word('char-font')                              => %w[lispFunc Statement],
        word('logical-pathname')                       => %w[lispFunc Statement],
        word('slot-boundp')                            => %w[lispFunc Statement],
        word('char-font-limit')                        => %w[lispFunc Statement],
        word('logical-pathname-translations')          => %w[lispFunc Statement],
        word('slot-exists-p')                          => %w[lispFunc Statement],
        word('char-greaterp')                          => %w[lispFunc Statement],
        word('logior')                                 => %w[lispFunc Statement],
        word('slot-makunbound')                        => %w[lispFunc Statement],
        word('char-hyper-bit')                         => %w[lispFunc Statement],
        word('lognand')                                => %w[lispFunc Statement],
        word('slot-missing')                           => %w[lispFunc Statement],
        word('char-int')                               => %w[lispFunc Statement],
        word('lognor')                                 => %w[lispFunc Statement],
        word('slot-unbound')                           => %w[lispFunc Statement],
        word('char-lessp')                             => %w[lispFunc Statement],
        word('lognot')                                 => %w[lispFunc Statement],
        word('slot-value')                             => %w[lispFunc Statement],
        word('char-meta-bit')                          => %w[lispFunc Statement],
        word('logorc1')                                => %w[lispFunc Statement],
        word('software-type')                          => %w[lispFunc Statement],
        word('char-name')                              => %w[lispFunc Statement],
        word('logorc2')                                => %w[lispFunc Statement],
        word('software-version')                       => %w[lispFunc Statement],
        word('char-not-equal')                         => %w[lispFunc Statement],
        word('logtest')                                => %w[lispFunc Statement],
        word('some')                                   => %w[lispFunc Statement],
        word('char-not-greaterp')                      => %w[lispFunc Statement],
        word('logxor')                                 => %w[lispFunc Statement],
        word('sort')                                   => %w[lispFunc Statement],
        word('char-not-lessp')                         => %w[lispFunc Statement],
        word('long-float')                             => %w[lispFunc Statement],
        word('space')                                  => %w[lispFunc Statement],
        word('char-super-bit')                         => %w[lispFunc Statement],
        word('long-float-epsilon')                     => %w[lispFunc Statement],
        word('special')                                => %w[lispFunc Statement],
        word('char-upcase')                            => %w[lispFunc Statement],
        word('long-float-negative-epsilon')            => %w[lispFunc Statement],
        word('special-form-p')                         => %w[lispFunc Statement],
        word('check-type')                             => %w[lispFunc Statement],
        word('long-site-name')                         => %w[lispFunc Statement],
        word('special-operator-p')                     => %w[lispFunc Statement],
        word('cis')                                    => %w[lispFunc Statement],
        word('loop')                                   => %w[lispFunc Statement],
        word('speed')                                  => %w[lispFunc Statement],
        word('class')                                  => %w[lispFunc Statement],
        word('loop-finish')                            => %w[lispFunc Statement],
        word('sqrt')                                   => %w[lispFunc Statement],
        word('class-name')                             => %w[lispFunc Statement],
        word('lower-case-p')                           => %w[lispFunc Statement],
        word('stable-sort')                            => %w[lispFunc Statement],
        word('class-of')                               => %w[lispFunc Statement],
        word('machine-instance')                       => %w[lispFunc Statement],
        word('standard')                               => %w[lispFunc Statement],
        word('clear-input')                            => %w[lispFunc Statement],
        word('machine-type')                           => %w[lispFunc Statement],
        word('standard-char')                          => %w[lispFunc Statement],
        word('clear-output')                           => %w[lispFunc Statement],
        word('machine-version')                        => %w[lispFunc Statement],
        word('standard-char-p')                        => %w[lispFunc Statement],
        word('close')                                  => %w[lispFunc Statement],
        word('macroexpand')                            => %w[lispFunc Statement],
        word('standard-class')                         => %w[lispFunc Statement],
        word('clrhash')                                => %w[lispFunc Statement],
        word('macroexpand-1')                          => %w[lispFunc Statement],
        word('standard-generic-function')              => %w[lispFunc Statement],
        word('code-char')                              => %w[lispFunc Statement],
        word('macroexpand-l')                          => %w[lispFunc Statement],
        word('standard-method')                        => %w[lispFunc Statement],
        word('coerce')                                 => %w[lispFunc Statement],
        word('macro-function')                         => %w[lispFunc Statement],
        word('standard-object')                        => %w[lispFunc Statement],
        word('commonp')                                => %w[lispFunc Statement],
        word('macrolet')                               => %w[lispFunc Statement],
        word('step')                                   => %w[lispFunc Statement],
        word('compilation-speed')                      => %w[lispFunc Statement],
        word('make-array')                             => %w[lispFunc Statement],
        word('storage-condition')                      => %w[lispFunc Statement],
        word('compile')                                => %w[lispFunc Statement],
        word('make-array')                             => %w[lispFunc Statement],
        word('store-value')                            => %w[lispFunc Statement],
        word('compiled-function')                      => %w[lispFunc Statement],
        word('make-broadcast-stream')                  => %w[lispFunc Statement],
        word('stream')                                 => %w[lispFunc Statement],
        word('compiled-function-p')                    => %w[lispFunc Statement],
        word('make-char')                              => %w[lispFunc Statement],
        word('stream-element-type')                    => %w[lispFunc Statement],
        word('compile-file')                           => %w[lispFunc Statement],
        word('make-concatenated-stream')               => %w[lispFunc Statement],
        word('stream-error')                           => %w[lispFunc Statement],
        word('compile-file-pathname')                  => %w[lispFunc Statement],
        word('make-condition')                         => %w[lispFunc Statement],
        word('stream-error-stream')                    => %w[lispFunc Statement],
        word('compiler-let')                           => %w[lispFunc Statement],
        word('make-dispatch-macro-character')          => %w[lispFunc Statement],
        word('stream-external-format')                 => %w[lispFunc Statement],
        word('compiler-macro')                         => %w[lispFunc Statement],
        word('make-echo-stream')                       => %w[lispFunc Statement],
        word('streamp')                                => %w[lispFunc Statement],
        word('compiler-macro-function')                => %w[lispFunc Statement],
        word('make-hash-table')                        => %w[lispFunc Statement],
        word('streamup')                               => %w[lispFunc Statement],
        word('complement')                             => %w[lispFunc Statement],
        word('make-instance')                          => %w[lispFunc Statement],
        word('string')                                 => %w[lispFunc Statement],
        word('complex')                                => %w[lispFunc Statement],
        word('make-instances-obsolete')                => %w[lispFunc Statement],
        region('string<')                              => %w[lispFunc Statement],
        word('complexp')                               => %w[lispFunc Statement],
        word('make-list')                              => %w[lispFunc Statement],
        region('string<=')                             => %w[lispFunc Statement],
        word('compute-applicable-methods')             => %w[lispFunc Statement],
        word('make-load-form')                         => %w[lispFunc Statement],
        region('string=')                              => %w[lispFunc Statement],
        word('compute-restarts')                       => %w[lispFunc Statement],
        word('make-load-form-saving-slots')            => %w[lispFunc Statement],
        region('string>')                              => %w[lispFunc Statement],
        word('concatenate')                            => %w[lispFunc Statement],
        word('make-method')                            => %w[lispFunc Statement],
        region('string>=')                             => %w[lispFunc Statement],
        word('concatenated-stream')                    => %w[lispFunc Statement],
        word('make-package')                           => %w[lispFunc Statement],
        region('string/=')                             => %w[lispFunc Statement],
        word('concatenated-stream-streams')            => %w[lispFunc Statement],
        word('make-pathname')                          => %w[lispFunc Statement],
        word('string-capitalize')                      => %w[lispFunc Statement],
        word('cond')                                   => %w[lispFunc Statement],
        word('make-random-state')                      => %w[lispFunc Statement],
        word('string-char')                            => %w[lispFunc Statement],
        word('condition')                              => %w[lispFunc Statement],
        word('make-sequence')                          => %w[lispFunc Statement],
        word('string-char-p')                          => %w[lispFunc Statement],
        word('conjugate')                              => %w[lispFunc Statement],
        word('make-string')                            => %w[lispFunc Statement],
        word('string-downcase')                        => %w[lispFunc Statement],
        word('cons')                                   => %w[lispFunc Statement],
        word('make-string-input-stream')               => %w[lispFunc Statement],
        word('string-equal')                           => %w[lispFunc Statement],
        word('consp')                                  => %w[lispFunc Statement],
        word('make-string-output-stream')              => %w[lispFunc Statement],
        word('string-greaterp')                        => %w[lispFunc Statement],
        word('constantly')                             => %w[lispFunc Statement],
        word('make-symbol')                            => %w[lispFunc Statement],
        word('string-left-trim')                       => %w[lispFunc Statement],
        word('constantp')                              => %w[lispFunc Statement],
        word('make-synonym-stream')                    => %w[lispFunc Statement],
        word('string-lessp')                           => %w[lispFunc Statement],
        word('continue')                               => %w[lispFunc Statement],
        word('make-two-way-stream')                    => %w[lispFunc Statement],
        word('string-not-equal')                       => %w[lispFunc Statement],
        word('control-error')                          => %w[lispFunc Statement],
        word('makunbound')                             => %w[lispFunc Statement],
        word('string-not-greaterp')                    => %w[lispFunc Statement],
        word('copy-alist')                             => %w[lispFunc Statement],
        word('map')                                    => %w[lispFunc Statement],
        word('string-not-lessp')                       => %w[lispFunc Statement],
        word('copy-list')                              => %w[lispFunc Statement],
        word('mapc')                                   => %w[lispFunc Statement],
        word('stringp')                                => %w[lispFunc Statement],
        word('copy-pprint-dispatch')                   => %w[lispFunc Statement],
        word('mapcan')                                 => %w[lispFunc Statement],
        word('string-right-strim')                     => %w[lispFunc Statement],
        word('copy-readtable')                         => %w[lispFunc Statement],
        word('mapcar')                                 => %w[lispFunc Statement],
        word('string-right-trim')                      => %w[lispFunc Statement],
        word('copy-seq')                               => %w[lispFunc Statement],
        word('mapcon')                                 => %w[lispFunc Statement],
        word('string-stream')                          => %w[lispFunc Statement],
        word('copy-structure')                         => %w[lispFunc Statement],
        word('maphash')                                => %w[lispFunc Statement],
        word('string-trim')                            => %w[lispFunc Statement],
        word('copy-symbol')                            => %w[lispFunc Statement],
        word('map-into')                               => %w[lispFunc Statement],
        word('string-upcase')                          => %w[lispFunc Statement],
        word('copy-tree')                              => %w[lispFunc Statement],
        word('mapl')                                   => %w[lispFunc Statement],
        word('structure')                              => %w[lispFunc Statement],
        word('cos')                                    => %w[lispFunc Statement],
        word('maplist')                                => %w[lispFunc Statement],
        word('structure-class')                        => %w[lispFunc Statement],
        word('cosh')                                   => %w[lispFunc Statement],
        word('mask-field')                             => %w[lispFunc Statement],
        word('structure-object')                       => %w[lispFunc Statement],
        word('count')                                  => %w[lispFunc Statement],
        word('max')                                    => %w[lispFunc Statement],
        word('style-warning')                          => %w[lispFunc Statement],
        word('count-if')                               => %w[lispFunc Statement],
        word('member')                                 => %w[lispFunc Statement],
        word('sublim')                                 => %w[lispFunc Statement],
        word('count-if-not')                           => %w[lispFunc Statement],
        word('member-if')                              => %w[lispFunc Statement],
        word('sublis')                                 => %w[lispFunc Statement],
        word('ctypecase')                              => %w[lispFunc Statement],
        word('member-if-not')                          => %w[lispFunc Statement],
        word('subseq')                                 => %w[lispFunc Statement],
        word('debug')                                  => %w[lispFunc Statement],
        word('merge')                                  => %w[lispFunc Statement],
        word('subsetp')                                => %w[lispFunc Statement],
        word('decf')                                   => %w[lispFunc Statement],
        word('merge-pathname')                         => %w[lispFunc Statement],
        word('subst')                                  => %w[lispFunc Statement],
        word('declaim')                                => %w[lispFunc Statement],
        word('merge-pathnames')                        => %w[lispFunc Statement],
        word('subst-if')                               => %w[lispFunc Statement],
        word('declaration')                            => %w[lispFunc Statement],
        word('method')                                 => %w[lispFunc Statement],
        word('subst-if-not')                           => %w[lispFunc Statement],
        word('declare')                                => %w[lispFunc Statement],
        word('method-combination')                     => %w[lispFunc Statement],
        word('substitute')                             => %w[lispFunc Statement],
        word('decode-float')                           => %w[lispFunc Statement],
        word('method-combination-error')               => %w[lispFunc Statement],
        word('substitute-if')                          => %w[lispFunc Statement],
        word('decode-universal-time')                  => %w[lispFunc Statement],
        word('method-qualifiers')                      => %w[lispFunc Statement],
        word('substitute-if-not')                      => %w[lispFunc Statement],
        word('defclass')                               => %w[lispFunc Statement],
        word('min')                                    => %w[lispFunc Statement],
        word('subtypep')                               => %w[lispFunc Statement],
        word('defconstant')                            => %w[lispFunc Statement],
        word('minusp')                                 => %w[lispFunc Statement],
        word('svref')                                  => %w[lispFunc Statement],
        word('defgeneric')                             => %w[lispFunc Statement],
        word('mismatch')                               => %w[lispFunc Statement],
        word('sxhash')                                 => %w[lispFunc Statement],
        word('define-compiler-macro')                  => %w[lispFunc Statement],
        word('mod')                                    => %w[lispFunc Statement],
        word('symbol')                                 => %w[lispFunc Statement],
        word('define-condition')                       => %w[lispFunc Statement],
        word('most-negative-double-float')             => %w[lispFunc Statement],
        word('symbol-function')                        => %w[lispFunc Statement],
        word('define-method-combination')              => %w[lispFunc Statement],
        word('most-negative-fixnum')                   => %w[lispFunc Statement],
        word('symbol-macrolet')                        => %w[lispFunc Statement],
        word('define-modify-macro')                    => %w[lispFunc Statement],
        word('most-negative-long-float')               => %w[lispFunc Statement],
        word('symbol-name')                            => %w[lispFunc Statement],
        word('define-setf-expander')                   => %w[lispFunc Statement],
        word('most-negative-short-float')              => %w[lispFunc Statement],
        word('symbolp')                                => %w[lispFunc Statement],
        word('define-setf-method')                     => %w[lispFunc Statement],
        word('most-negative-single-float')             => %w[lispFunc Statement],
        word('symbol-package')                         => %w[lispFunc Statement],
        word('define-symbol-macro')                    => %w[lispFunc Statement],
        word('most-positive-double-float')             => %w[lispFunc Statement],
        word('symbol-plist')                           => %w[lispFunc Statement],
        word('defmacro')                               => %w[lispFunc Statement],
        word('most-positive-fixnum')                   => %w[lispFunc Statement],
        word('symbol-value')                           => %w[lispFunc Statement],
        word('defmethod')                              => %w[lispFunc Statement],
        word('most-positive-long-float')               => %w[lispFunc Statement],
        word('synonym-stream')                         => %w[lispFunc Statement],
        word('defpackage')                             => %w[lispFunc Statement],
        word('most-positive-short-float')              => %w[lispFunc Statement],
        word('synonym-stream-symbol')                  => %w[lispFunc Statement],
        word('defparameter')                           => %w[lispFunc Statement],
        word('most-positive-single-float')             => %w[lispFunc Statement],
        word('sys')                                    => %w[lispFunc Statement],
        word('defsetf')                                => %w[lispFunc Statement],
        word('muffle-warning')                         => %w[lispFunc Statement],
        word('system')                                 => %w[lispFunc Statement],
        word('defstruct')                              => %w[lispFunc Statement],
        word('multiple-value-bind')                    => %w[lispFunc Statement],
        word('t')                                      => %w[lispFunc Statement],
        word('deftype')                                => %w[lispFunc Statement],
        word('multiple-value-call')                    => %w[lispFunc Statement],
        word('tagbody')                                => %w[lispFunc Statement],
        word('defun')                                  => %w[lispFunc Statement],
        word('multiple-value-list')                    => %w[lispFunc Statement],
        word('tailp')                                  => %w[lispFunc Statement],
        word('defvar')                                 => %w[lispFunc Statement],
        word('multiple-value-prog1')                   => %w[lispFunc Statement],
        word('tan')                                    => %w[lispFunc Statement],
        word('delete')                                 => %w[lispFunc Statement],
        word('multiple-value-seteq')                   => %w[lispFunc Statement],
        word('tanh')                                   => %w[lispFunc Statement],
        word('delete-duplicates')                      => %w[lispFunc Statement],
        word('multiple-value-setq')                    => %w[lispFunc Statement],
        word('tenth')                                  => %w[lispFunc Statement],
        word('delete-file')                            => %w[lispFunc Statement],
        word('multiple-values-limit')                  => %w[lispFunc Statement],
        word('terpri')                                 => %w[lispFunc Statement],
        word('delete-if')                              => %w[lispFunc Statement],
        word('name-char')                              => %w[lispFunc Statement],
        word('the')                                    => %w[lispFunc Statement],
        word('delete-if-not')                          => %w[lispFunc Statement],
        word('namestring')                             => %w[lispFunc Statement],
        word('third')                                  => %w[lispFunc Statement],
        word('delete-package')                         => %w[lispFunc Statement],
        word('nbutlast')                               => %w[lispFunc Statement],
        word('throw')                                  => %w[lispFunc Statement],
        word('denominator')                            => %w[lispFunc Statement],
        word('nconc')                                  => %w[lispFunc Statement],
        word('time')                                   => %w[lispFunc Statement],
        word('deposit-field')                          => %w[lispFunc Statement],
        word('next-method-p')                          => %w[lispFunc Statement],
        word('trace')                                  => %w[lispFunc Statement],
        word('describe')                               => %w[lispFunc Statement],
        word('nil')                                    => %w[lispFunc Statement],
        word('translate-logical-pathname')             => %w[lispFunc Statement],
        word('describe-object')                        => %w[lispFunc Statement],
        word('nintersection')                          => %w[lispFunc Statement],
        word('translate-pathname')                     => %w[lispFunc Statement],
        word('destructuring-bind')                     => %w[lispFunc Statement],
        word('ninth')                                  => %w[lispFunc Statement],
        word('tree-equal')                             => %w[lispFunc Statement],
        word('digit-char')                             => %w[lispFunc Statement],
        word('no-applicable-method')                   => %w[lispFunc Statement],
        word('truename')                               => %w[lispFunc Statement],
        word('digit-char-p')                           => %w[lispFunc Statement],
        word('no-next-method')                         => %w[lispFunc Statement],
        word('truncase')                               => %w[lispFunc Statement],
        word('directory')                              => %w[lispFunc Statement],
        word('not')                                    => %w[lispFunc Statement],
        word('truncate')                               => %w[lispFunc Statement],
        word('directory-namestring')                   => %w[lispFunc Statement],
        word('notany')                                 => %w[lispFunc Statement],
        word('two-way-stream')                         => %w[lispFunc Statement],
        word('disassemble')                            => %w[lispFunc Statement],
        word('notevery')                               => %w[lispFunc Statement],
        word('two-way-stream-input-stream')            => %w[lispFunc Statement],
        word('division-by-zero')                       => %w[lispFunc Statement],
        word('notinline')                              => %w[lispFunc Statement],
        word('two-way-stream-output-stream')           => %w[lispFunc Statement],
        word('do')                                     => %w[lispFunc Statement],
        word('nreconc')                                => %w[lispFunc Statement],
        word('type')                                   => %w[lispFunc Statement],
        region('do\\\\*')                              => %w[lispFunc Statement],
        word('nreverse')                               => %w[lispFunc Statement],
        word('typecase')                               => %w[lispFunc Statement],
        word('do-all-symbols')                         => %w[lispFunc Statement],
        word('nset-difference')                        => %w[lispFunc Statement],
        word('type-error')                             => %w[lispFunc Statement],
        word('documentation')                          => %w[lispFunc Statement],
        word('nset-exclusive-or')                      => %w[lispFunc Statement],
        word('type-error-datum')                       => %w[lispFunc Statement],
        word('do-exeternal-symbols')                   => %w[lispFunc Statement],
        word('nstring')                                => %w[lispFunc Statement],
        word('type-error-expected-type')               => %w[lispFunc Statement],
        word('do-external-symbols')                    => %w[lispFunc Statement],
        word('nstring-capitalize')                     => %w[lispFunc Statement],
        word('type-of')                                => %w[lispFunc Statement],
        word('dolist')                                 => %w[lispFunc Statement],
        word('nstring-downcase')                       => %w[lispFunc Statement],
        word('typep')                                  => %w[lispFunc Statement],
        word('do-symbols')                             => %w[lispFunc Statement],
        word('nstring-upcase')                         => %w[lispFunc Statement],
        word('unbound-slot')                           => %w[lispFunc Statement],
        word('dotimes')                                => %w[lispFunc Statement],
        word('nsublis')                                => %w[lispFunc Statement],
        word('unbound-slot-instance')                  => %w[lispFunc Statement],
        word('double-float')                           => %w[lispFunc Statement],
        word('nsubst')                                 => %w[lispFunc Statement],
        word('unbound-variable')                       => %w[lispFunc Statement],
        word('double-float-epsilon')                   => %w[lispFunc Statement],
        word('nsubst-if')                              => %w[lispFunc Statement],
        word('undefined-function')                     => %w[lispFunc Statement],
        word('double-float-negative-epsilon')          => %w[lispFunc Statement],
        word('nsubst-if-not')                          => %w[lispFunc Statement],
        word('unexport')                               => %w[lispFunc Statement],
        word('dpb')                                    => %w[lispFunc Statement],
        word('nsubstitute')                            => %w[lispFunc Statement],
        word('unintern')                               => %w[lispFunc Statement],
        word('dribble')                                => %w[lispFunc Statement],
        word('nsubstitute-if')                         => %w[lispFunc Statement],
        word('union')                                  => %w[lispFunc Statement],
        word('dynamic-extent')                         => %w[lispFunc Statement],
        word('nsubstitute-if-not')                     => %w[lispFunc Statement],
        word('unless')                                 => %w[lispFunc Statement],
        word('ecase')                                  => %w[lispFunc Statement],
        word('nth')                                    => %w[lispFunc Statement],
        word('unread')                                 => %w[lispFunc Statement],
        word('echo-stream')                            => %w[lispFunc Statement],
        word('nthcdr')                                 => %w[lispFunc Statement],
        word('unread-char')                            => %w[lispFunc Statement],
        word('echo-stream-input-stream')               => %w[lispFunc Statement],
        word('nth-value')                              => %w[lispFunc Statement],
        word('unsigned-byte')                          => %w[lispFunc Statement],
        word('echo-stream-output-stream')              => %w[lispFunc Statement],
        word('null')                                   => %w[lispFunc Statement],
        word('untrace')                                => %w[lispFunc Statement],
        word('ed')                                     => %w[lispFunc Statement],
        word('number')                                 => %w[lispFunc Statement],
        word('unuse-package')                          => %w[lispFunc Statement],
        word('eighth')                                 => %w[lispFunc Statement],
        word('numberp')                                => %w[lispFunc Statement],
        word('unwind-protect')                         => %w[lispFunc Statement],
        word('elt')                                    => %w[lispFunc Statement],
        word('numerator')                              => %w[lispFunc Statement],
        word('update-instance-for-different-class')    => %w[lispFunc Statement],
        word('encode-universal-time')                  => %w[lispFunc Statement],
        word('nunion')                                 => %w[lispFunc Statement],
        word('update-instance-for-redefined-class')    => %w[lispFunc Statement],
        word('end-of-file')                            => %w[lispFunc Statement],
        word('oddp')                                   => %w[lispFunc Statement],
        word('upgraded-array-element-type')            => %w[lispFunc Statement],
        word('endp')                                   => %w[lispFunc Statement],
        word('open')                                   => %w[lispFunc Statement],
        word('upgraded-complex-part-type')             => %w[lispFunc Statement],
        word('enough-namestring')                      => %w[lispFunc Statement],
        word('open-stream-p')                          => %w[lispFunc Statement],
        word('upper-case-p')                           => %w[lispFunc Statement],
        word('ensure-directories-exist')               => %w[lispFunc Statement],
        word('optimize')                               => %w[lispFunc Statement],
        word('use-package')                            => %w[lispFunc Statement],
        word('ensure-generic-function')                => %w[lispFunc Statement],
        word('or')                                     => %w[lispFunc Statement],
        word('user')                                   => %w[lispFunc Statement],
        word('eq')                                     => %w[lispFunc Statement],
        word('otherwise')                              => %w[lispFunc Statement],
        word('user-homedir-pathname')                  => %w[lispFunc Statement],
        word('eql')                                    => %w[lispFunc Statement],
        word('output-stream-p')                        => %w[lispFunc Statement],
        word('use-value')                              => %w[lispFunc Statement],
        word('equal')                                  => %w[lispFunc Statement],
        word('package')                                => %w[lispFunc Statement],
        word('values')                                 => %w[lispFunc Statement],
        word('equalp')                                 => %w[lispFunc Statement],
        word('package-error')                          => %w[lispFunc Statement],
        word('values-list')                            => %w[lispFunc Statement],
        word('error')                                  => %w[lispFunc Statement],
        word('package-error-package')                  => %w[lispFunc Statement],
        word('variable')                               => %w[lispFunc Statement],
        word('etypecase')                              => %w[lispFunc Statement],
        word('package-name')                           => %w[lispFunc Statement],
        word('vector')                                 => %w[lispFunc Statement],
        word('eval')                                   => %w[lispFunc Statement],
        word('package-nicknames')                      => %w[lispFunc Statement],
        word('vectorp')                                => %w[lispFunc Statement],
        word('evalhook')                               => %w[lispFunc Statement],
        word('packagep')                               => %w[lispFunc Statement],
        word('vector-pop')                             => %w[lispFunc Statement],
        word('eval-when')                              => %w[lispFunc Statement],
        word('package-shadowing-symbols')              => %w[lispFunc Statement],
        word('vector-push')                            => %w[lispFunc Statement],
        word('evenp')                                  => %w[lispFunc Statement],
        word('package-used-by-list')                   => %w[lispFunc Statement],
        word('vector-push-extend')                     => %w[lispFunc Statement],
        word('every')                                  => %w[lispFunc Statement],
        word('package-use-list')                       => %w[lispFunc Statement],
        word('warn')                                   => %w[lispFunc Statement],
        word('exp')                                    => %w[lispFunc Statement],
        word('pairlis')                                => %w[lispFunc Statement],
        word('warning')                                => %w[lispFunc Statement],
        word('export')                                 => %w[lispFunc Statement],
        word('parse-error')                            => %w[lispFunc Statement],
        word('when')                                   => %w[lispFunc Statement],
        word('expt')                                   => %w[lispFunc Statement],
        word('parse-integer')                          => %w[lispFunc Statement],
        word('wild-pathname-p')                        => %w[lispFunc Statement],
        word('extended-char')                          => %w[lispFunc Statement],
        word('parse-namestring')                       => %w[lispFunc Statement],
        word('with-accessors')                         => %w[lispFunc Statement],
        word('fboundp')                                => %w[lispFunc Statement],
        word('pathname')                               => %w[lispFunc Statement],
        word('with-compilation-unit')                  => %w[lispFunc Statement],
        word('fceiling')                               => %w[lispFunc Statement],
        word('pathname-device')                        => %w[lispFunc Statement],
        word('with-condition-restarts')                => %w[lispFunc Statement],
        word('fdefinition')                            => %w[lispFunc Statement],
        word('pathname-directory')                     => %w[lispFunc Statement],
        word('with-hash-table-iterator')               => %w[lispFunc Statement],
        word('ffloor')                                 => %w[lispFunc Statement],
        word('pathname-host')                          => %w[lispFunc Statement],
        word('with-input-from-string')                 => %w[lispFunc Statement],
        word('fifth')                                  => %w[lispFunc Statement],
        word('pathname-match-p')                       => %w[lispFunc Statement],
        word('with-open-file')                         => %w[lispFunc Statement],
        word('file-author')                            => %w[lispFunc Statement],
        word('pathname-name')                          => %w[lispFunc Statement],
        word('with-open-stream')                       => %w[lispFunc Statement],
        word('file-error')                             => %w[lispFunc Statement],
        word('pathnamep')                              => %w[lispFunc Statement],
        word('with-output-to-string')                  => %w[lispFunc Statement],
        word('file-error-pathname')                    => %w[lispFunc Statement],
        word('pathname-type')                          => %w[lispFunc Statement],
        word('with-package-iterator')                  => %w[lispFunc Statement],
        word('file-length')                            => %w[lispFunc Statement],
        word('pathname-version')                       => %w[lispFunc Statement],
        word('with-simple-restart')                    => %w[lispFunc Statement],
        word('file-namestring')                        => %w[lispFunc Statement],
        word('peek-char')                              => %w[lispFunc Statement],
        word('with-slots')                             => %w[lispFunc Statement],
        word('file-position')                          => %w[lispFunc Statement],
        word('phase')                                  => %w[lispFunc Statement],
        word('with-standard-io-syntax')                => %w[lispFunc Statement],
        word('file-stream')                            => %w[lispFunc Statement],
        word('pi')                                     => %w[lispFunc Statement],
        word('write')                                  => %w[lispFunc Statement],
        word('file-string-length')                     => %w[lispFunc Statement],
        word('plusp')                                  => %w[lispFunc Statement],
        word('write-byte')                             => %w[lispFunc Statement],
        word('file-write-date')                        => %w[lispFunc Statement],
        word('pop')                                    => %w[lispFunc Statement],
        word('write-char')                             => %w[lispFunc Statement],
        word('fill')                                   => %w[lispFunc Statement],
        word('position')                               => %w[lispFunc Statement],
        word('write-line')                             => %w[lispFunc Statement],
        word('fill-pointer')                           => %w[lispFunc Statement],
        word('position-if')                            => %w[lispFunc Statement],
        word('write-sequence')                         => %w[lispFunc Statement],
        word('find')                                   => %w[lispFunc Statement],
        word('position-if-not')                        => %w[lispFunc Statement],
        word('write-string')                           => %w[lispFunc Statement],
        word('find-all-symbols')                       => %w[lispFunc Statement],
        word('pprint')                                 => %w[lispFunc Statement],
        word('write-to-string')                        => %w[lispFunc Statement],
        word('find-class')                             => %w[lispFunc Statement],
        word('pprint-dispatch')                        => %w[lispFunc Statement],
        word('yes-or-no-p')                            => %w[lispFunc Statement],
        word('find-if')                                => %w[lispFunc Statement],
        word('pprint-exit-if-list-exhausted')          => %w[lispFunc Statement],
        word('y-or-n-p')                               => %w[lispFunc Statement],
        word('find-if-not')                            => %w[lispFunc Statement],
        word('pprint-fill')                            => %w[lispFunc Statement],
        word('zerop')                                  => %w[lispFunc Statement],
        word('true')                                   => %w[lispFunc Statement],
        word('false')                                  => %w[lispFunc Statement],

        region('"lispString"')                         => %w[lispString String],
        region('"lispString\\\\"')                     => %w[lispString String],
        region('"lispString')                          => %w[lispString String],

        region('lispAtom1')                            => %w[lispAtom Identifier],
        region('"lispAtom2"')                          => %w[lispAtom Identifier],
        region('"lispAtom3')                           => %w[lispAtom Identifier],

        region(';lispComment1')                        => %w[lispComment Comment],
        region('; lispComment2')                       => %w[lispComment Comment],

        region('#|lispComment3|#')                     => %w[lispComment Comment],
        region('#| lispComment4 |#')                   => %w[lispComment Comment],
        region('#|lispComment5')                       => %w[lispComment Comment],
        region('#| lispComment6')                      => %w[lispComment Comment],

        region('&optional')                            => %w[lispKey Type],
        region(':while')                               => %w[lispKey Type]
      )
    end
  end
end
