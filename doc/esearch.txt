*esearch.txt*  NeoVim/Vim plugin performing project-wide async search
and replace, similar to SublimeText, Atom et al.

CONTENTS                                               *vim-esearch-help-contents*

Features overview     |vim-esearch-features|         
Install               |vim-esearch-install|   
Quick start           |vim-esearch-quickstart|   
Global                |vim-esearch-global|   
  Mappings              |vim-esearch-global-map|   
  Configurations        |vim-esearch-global-config|   
Search window         |vim-esearch-win|   
  Mappings              |vim-esearch-win-map|   
  Configurations        |vim-esearch-win-config|   
  Preview               |vim-esearch-win-preview|   
Commandline           |vim-esearch-cmdline|   
  Prompt                |vim-esearch-cmdline-prompt|   
  Menu                  |vim-esearch-cmdline-menu|   
Appearance            |vim-esearch-appearance|   
Performance           |vim-esearch-performance|   
API                   |vim-esearch-api|   
  Global functions      |vim-esearch-api-global-functions|   
  Local functions       |vim-esearch-api-local-functions|   
  Events                |vim-esearch-api-events|   
  Usage examples        |vim-esearch-api-examples|   
Troubleshooting       |vim-esearch-troubleshooting|   
About                 |vim-esearch-about|   

================================================================================
FEATURES OVERVIEW                                           *vim-esearch-features*

- Simplicity (no dependencies, pattern are auto-escaped).
- High performance:
  - Fully async functioning using neovim/vim8 jobs api.
  - Fast lua-based rendering (up to 40k lines in less than a second).
  - Viewport position-based highlights (neovim only).
  - Adaptive disabling of certain highlights on a large number of lines.
- In-place modifying and saving changes into files.
- Filetype-dependent syntax highlights for better navigation.
- Input prompt interface instead of using the commandline:
  - Search patterns can be pasted as is
  - Pcre-to-vim regex translation to highlight matches.
- 2 preview modes using both neovim floating windows or plain split windows.
- Interactions are done via API methods, that can be modified or reused to
  personalize the workflow.
- Third party plugins integration:
  - vim-visual-multi (multiple cursors plugin) is guarded from editing
    filenames and line numbers.
  - Most of file browsers (nerdtree, dirvish, netranger, defx) can be used to
    specify search paths.

================================================================================
INSTALL                                                      *vim-esearch-install*

Add one of the following lines depending on your plugin manager:
>
    call   minpac#add('eugen0329/vim-esearch')
    call   dein#add('eugen0329/vim-esearch')
    Plug   'eugen0329/vim-esearch'
    Plugin 'eugen0329/vim-esearch'
<
Recommended: install [rg], [ag], [ack] or [pt] for faster searching and extra
features. Otherwise, grep or git-grep will be used.

              [rg]  https://github.com/BurntSushi/ripgrep#installation
              [ag]  https://github.com/ggreer/the_silver_searcher#installing
              [ack] https://beyondgrep.com/install/
              [pt]  https://github.com/monochromegane/the_platinum_searcher#user

================================================================================
QUICK START                                               *vim-esearch-quickstart*

Start searching~
    Type `<leader>ff` keys (`<leader>` is `\` unless redefined) to open the
    prompt. Use `<c-r><c-r>`, `<c-s><c-s>` and `<c-t><c-t>` within the prompt
    to cycle through regex, case sensitive and text-objects matching modes or
    use `<c-o>` to open a menu to set searching paths, filetypes or other
    configs.

Navigation~
    Within the search window use `J` and `K` to jump between entries or `{`
    and `}` to jump between filenames.

Open files~
    To open a line in a file press `<Enter>` (open in the current window), `o`
    (open in a split), `s` (split vertically) or `t` to open in a new tab. Use
    the keys with shift pressed (`O`, `S` and `T`) to open staying in the
    search window.

Make changes~
    Modify or delete the results right inside the search window and type
    `:write<CR>`` to save your changes into files.

Preview~
    Press `p` to open a preview window. Use multiple `p` to zoom it and
    capital `P` to enter the preview for express changes (without moving to a
    separate split window).

================================================================================
GLOBAL                                                        *vim-esearch-global*

GLOBAL MAPPINGS                                           *vim-esearch-global-map*

           Map                                 Comment ~
 ------------------------+------------------------------------------------------
 <plug>(esearch)         | Start the input prompt.
 <plug>(esearch-prefill) | Operator to start the prompt pre-filled by a textobj.
 <plug>(esearch-exec)    | Operator to start a search for a textobj.
 ------------------------+------------------------------------------------------

Example configuration: >
  nmap <c-f><c-f> <plug>(esearch)
  map  <c-f>      <plug>(esearch-prefill)
  map  <c-m-f>    <plug>(esearch-prefill)
<
Will map `<c-f><c-f>` (double control-f) pressed twice to start the prompt,
pre-filled using one of specified strategies (see |esearch-prefill|). To
prefill the prompt with a text in braces like "(text to search)"  `<c-f>i(`
can be used. To start searching for the current word instantly `<c-m-f>iw` can
be pressed.

________________________________________________________________________________~
GLOBAL CONFIGURATIONS                                  *vim-esearch-global-config*

Configurations are scoped in `g:esearch` dictionary to make them easier to
review and to not create mess within the global namespace. This dictionary
will be inherited by any new search request.

To configure the plugin you must initialize it first with:
>
    let g:esearch = {}
<
Basic configurations:

        Property                              Comment~
 ------------------------+------------------------------------------------------
 `.default_mappings`       | Disable all default mappings
 `.regex`                  | To configure regex match modes
 `.case`                   | Configure case matching modes (smart, sensitive etc.)
 `.textobj`                | Configure textobj matching modes (word, line etc.)
 `.prefill`                | To configure the initial prompt content
 `.root_markers`           | List of filenames to determine a project root
 `.filetypes`              | String with filetypes to search only in them
 `.paths`                  | String with paths to search only
 `.select_prefilled`       | Use selection similar to visual
 `.adapter`                | Search util adapter name
 `.bckend`                 | Processing backend name
 `.out`                    | Output target name
 ------------------------+------------------------------------------------------

g:esearch.default_mappings                            *g:esearch.default_mappings*
        Disables all default mappings including bot global and search window
        local mappings.
        Allowed values: 1 or 0.
        Type: |Boolean|
        Default: 0
        Example:~
>
        let g:esearch.default_mappings = 1
<
g:esearch.regex                                                  *g:esearch.regex*
        To set regex matching by default change `let g:esearch.regex = 1` .
        Depending on what search util you use, you can specify explicityly
        what regex engine to use.
        E.g. for grep adapter you can specify 'extended' to use extended
        regex engine, `'basic'` to use basic regexs etc.
        Allowed values: `1`, `0` or engine name string (adapter dependent).
        Type: |Boolean| or |String|
        Default: 0
        Example:~
>
        let g:esearch.case = 'regex'
<

g:esearch.case                                                    *g:esearch.case*
        Sets case matching modes.
        Allowed values: `0`, `1`, 'ignore' (same as `0`), 'sensitive' (same as `1`) or
        'smart'.
        Type: |Boolean| or |String|
        Default: 0
        Example:~
>
        let g:esearch.case = 'smart'
<

g:esearch.textobj                                              *g:esearch.textobj*
        Configures to match only a specific text object (e.g. whole lines or whole
        words).
        Allowed values: `0`, 'none' (same as `0`), 'word' or 'line' (adapter
        dependent)
        Type: |Boolean| or |String|
        Default: 0
        Example:~
>
        let g:esearch.case = 'word'
<

g:esearch.prefill                                              *g:esearch.prefill*
        Configures a list of strategies to set an initial value of the prompt.
        Allowed list values: 'clipboard' (pre-fills with |clipboard| content),
        'hlsearch' (currently highlighted pattern searched with `/`), 'last'
        (last pattern search using the plugin), 'cword' (word under the
        cursor), 'current' (if within the search window - use the pattern
        TODO) or funcref.
        Type: |List| of |String| and |Funcref|s
        Default: ["hlsearch", "current", "last"]
        Example: ~
>
        let g:esearch.prefill = ['hlsearch', 'cword', { -> 'custom text' }]
<

g:esearch.root_markers                                    *g:esearch.root_markers*
        Tell the plugin what filenames to use to determine the root of your
        project.
        Type: |List| of |String|s
        Default: [".git", ".hg", ".svn", ".bzr", "_darcs"]
        Example:~
>
        let g:esearch.root_markers = ['.git', 'Makefile', 'node_modules']
<
g:esearch.filetypes                                          *g:esearch.filetypes*
        A string with space-separated filetypes, that tells the plugin what
        filenames to use to determine the root of your
        project.
        Type: |String|
        Default: ''
        Example:~
>
        let g:esearch.filetypes = 'python css js'
<

        NOTE: supported only by [ag], [rg] and [ack].

g:esearch.paths                                                  *g:esearch.paths*
        Contains paths to search in shell format.
        Type: ||String|
        Default: ''
        Example:~
>
        let g:esearch.filetypes = 'node_modules/ configs/**/*.yml'
<

        NOTE: to use all globbing features ensure, that |'shell'| option
        contains required options. E.g. for add to your vimrc:
        `set shell=bash\ -O\ globstar -O\ extglob`
        If you use OSX, install the latest bash version first using:
        `:!brew install bash`

g:esearch.select_prefilled                            *g:esearch.select_prefilled*
        Use visual-like selection of an initial prompt to be able to clear it
        fast or append/prepend the text. Input any regular key to overwrite
        the prefilled text or any special key like <c-e>, <c-a> or <right> to
        move the cursor without clearing the prompt.
        Type: |Boolean|
        Default: 0
        Example:~
>
        let g:esearch.select_initial = 0
<

g:esearch.before                                                *g:esearch.before*
g:esearch.after                                                  *g:esearch.after*
g:esearch.context                                              *g:esearch.context*
        Options to configure a number of lines to insert before, after or
        around the matching line correspondingly.
        Type: |Number|
        Allowed value: > 0.
        Default: 0
        Example:~
>
        let g:esearch.before = 1
        let g:esearch.after = 2
<
g:esearch.remember                                            *g:esearch.remember*
        Contains a list of values to remember for later search requests.
        Type: |List| of |String|s
        Allowed value: a list of |g:esearch| field names.
        Default:
          ["case", "textobj", "regex", "before",
          \ "filetypes", "paths", "after", "context"]
        Example:~
>
        let g:esearch.remember = ['case', 'regex', 'filetypes']
<
g:esearch.adapter                                              *g:esearch.adapter*
        Name of a search util to use.
        Type: |String|
        Allowed values: `'rg'`, `'ag'`, `'ack'`, `'pt'`, `'git'` or `'grep'`.
        Default: depends on executables availability.
        Example:~
>
        let g:esearch.adapter = 'grep'
<
g:esearch.backend                                              *g:esearch.backend*
        Name of a processing backend to use.
        Type: |String|
        Allowed values: `'nvim'`, `'vim8'`, `'vimproc'`, `'system'`
        Default: depends on editors features.
        Example:~
>
        let g:esearch.backend = 'system'
<
        NOTE Some backends are not synchronous (like system) or
        pseudo-asynchronous (like vimproc), so it's not recommended to redefine
        this option.

g:esearch.out                                                      *g:esearch.out*
        Target name to output results
        Type: |String|
        Allowed values: `'win'`, `'qflist'.
        Default: `'win'`
        Example:~
>
        let g:esearch.out = 'qflist'
<
        NOTE Quickfix list output contains far less features as it's vim's
        builtin feature.

================================================================================
SEARCH WINDOW                                                    *vim-esearch-win*

SEARCH WINDOW MAPPINGS                                       *vim-esearch-win-map*
                                                    *vim-esearch-win-map-defaults*

                 Map                   Default                   Comment~
 --------------------------------------+------+--------------------------------------------------------------
<plug>(esearch-win-reload)             |  R   | Reload current search
<plug>(esearch-win-tabopen)            |  t   | Open a file under the cursor in a tab
<plug>(esearch-win-tabopen:stay)       |  T   | Open in a tab and stay within the win
<plug>(esearch-win-split)              |  o   | Open a file under the cursor in a split
<plug>(esearch-win-split:reuse:stay)   |  O   | Open in a reusable split and stay within the win
<plug>(esearch-win-vsplit)             |  s   | Open a file under the cursor in a vertical split
<plug>(esearch-win-vsplit:reuse:stay)  |  S   | Open in a reusable vertical split and stay within the win
<plug>(esearch-win-open)               | <CR> | Open a file under the cursor in the window
<plug>(esearch-win-preview)            |  p   | Open the preview window
<plug>(esearch-win-preview:enter)      |  P   | Open the preview window and enter it
<plug>(esearch-win-jump:entry:down)    |  J   | Jump down to the next outputted line
<plug>(esearch-win-jump:entry:up)      |  K   | Jump up to the previous outputted line
<plug>(esearch-win-jump:filename:down) |  }   | Jump down to the next filename
<plug>(esearch-win-jump:filename:up)   |  {   | Jump up to the previous filename
<plug>(textobj-esearch-match-i)        |  im  | Seek forward and operate the next match
<plug>(textobj-esearch-match-a)        |  am  | Same as above, but capture surrounding whitespaces
 --------------------------------------+------+--------------------------------------------------------------

Use |g:esearch.win_map| to configure mappings or |esearch_win_config| event.

Example:~
>
        let g:esearch = {}
        let g:esearch.win_map = [
        \ {'lhs': 'e', 'rhs': '<plug>(esearch-win-vsplit)'},
        \ {'lhs': 'E', 'rhs': '<plug>(esearch-win-vsplit:stay)'},
        \]
<
See |maparg()| for other keys.

NOTE Options `{..., 'silent': 1, 'buffer': 1}` are added automatically. Don't
overwrite them to avoid side effects.

<plug>(esearch-win-reload)                            *<plug>(esearch-win-reload)*
        Reload the current search window.

<plug>(esearch-win-open)                                *<plug>(esearch-win-open)*
        Open a line in file under the cursor. To return back to the search window
        |CTRL-O| can be used (builtin vim command to jump to older cursor
        positions).
        Example:~
>
        let g:esearch.win_map = [
        \ {'lhs': 'e', 'rhs': '<plug>(esearch-win-open)'}
        \]
<
<plug>(esearch-win-tabopen)                          *<plug>(esearch-win-tabopen)*
<plug>(esearch-win-tabopen:stay)                *<plug>(esearch-win-tabopen:stay)*
        Open a line in file under the cursor in a new tab. If `:stay` is used -
        it doesn't move cursor to the opened file.

<plug>(esearch-win-split)                              *<plug>(esearch-win-split)*
<plug>(esearch-win-split:stay)                    *<plug>(esearch-win-split:stay)*
<plug>(esearch-win-split:reuse)                  *<plug>(esearch-win-split:reuse)*
<plug>(esearch-win-split:reuse:stay)        *<plug>(esearch-win-split:reuse:stay)*
        Open a line in file under the cursor in a horizontal split. If `:stay`
        is used - it doesn't move cursor to the opened file. If `:reuse` is
        used - reuse the opened window for all further opens.

<plug>(esearch-win-vsplit)                            *<plug>(esearch-win-vsplit)*
<plug>(esearch-win-vsplit:stay)                  *<plug>(esearch-win-vsplit:stay)*
<plug>(esearch-win-vsplit:reuse)                *<plug>(esearch-win-vsplit:reuse)*
<plug>(esearch-win-vsplit:reuse:stay)      *<plug>(esearch-win-vsplit:reuse:stay)*
        Open a line in file under the cursor in a vertical split. If `:stay` is
        used - it doesn't move cursor to the opened file. If `:reuse` is used -
        reuse the opened window for all further opens.

<plug>(esearch-win-preview)                          *<plug>(esearch-win-preview)*
<plug>(esearch-win-preview:enter)              *<plug>(esearch-win-preview:enter)*
        Open a line in file under the cursor in a preview window. If `:enter` is
        used - cursor will be moved into the opened window.
        Example:~
>
        let g:esearch.win_map = [
        \ {'lhs': ']f', 'rhs': '<plug>(esearch-win-jump:filename:up)'}
        \ {'lhs': '[f', 'rhs': '<plug>(esearch-win-jump:filename:down)'}
        \]
<
        NOTE: floating preview is only supported in neovim TODO VERSION. In
        vim split window will be used instead.

<plug>(esearch-win-jump:filename:up)        *<plug>(esearch-win-jump:filename:up)*
<plug>(esearch-win-jump:filename:down)    *<plug>(esearch-win-jump:filename:down)*
        Move cursor to a filename up or down.
        Example:~
>
        let g:esearch.win_map = [
        \ {'lhs': ']f', 'rhs': '<plug>(esearch-win-jump:filename:up)'}
        \ {'lhs': '[f', 'rhs': '<plug>(esearch-win-jump:filename:down)'}
        \]
<
<plug>(esearch-win-jump:entry:up)              *<plug>(esearch-win-jump:entry:up)*
<plug>(esearch-win-jump:entry:down)          *<plug>(esearch-win-jump:entry:down)*
        Move cursor to an outputted text line up or down.
        Example:~
>
        let g:esearch.win_map = [
        \ {'lhs': '<m-j>', 'rhs': '<plug>(esearch-win-jump:entry:up)'}
        \ {'lhs': '<m-k>', 'rhs': '<plug>(esearch-win-jump:entry:down)'}
        \]
<
<plug>(textobj-esearch-match-i)                  *<plug>(textobj-esearch-match-i)*
<plug>(textobj-esearch-match-a)                  *<plug>(textobj-esearch-match-a)*
        Seek a match under the cursor or on any line forward to start
        operating on it. <plug>(textobj-esearch-match-i) captures on the
        highlighted region, while <plug>(textobj-esearch-match-a) captures
        also trailing or leading whitespaces like |aw| text-object do
        Usage example: press `daw` to delete a match under the cursor with
        leading or trailing whitespaces or `ciw` to delete it and enter insert
        mode.
        Example:~
>
        let g:esearch.win_map = [
        \ {'lhs': 'ie', 'rhs': '<plug>(textobj-esearch-match-i)', 'mode': 'ov'}
        \ {'lhs': 'ae', 'rhs': '<plug>(textobj-esearch-match-a)', 'mode': 'ov'}
        \]
________________________________________________________________________________~
SEARCH WINDOW CONFIGURATIONS                              *vim-esearch-win-config*

Search window-related configurations are added to |g:esearch| dictionary.

Search window configurations:

            Property                              Comment~
 -----------------------------+-------------------------------------------------
 `.win_new`                     | Funcref to open a new window with search results
 `.win_map`                     | List of mapargs to define window-local mappings
 `.win_contexts_syntax`         | Use filetype-aware syntax highlights
 `.win_context_len_annotations` | Outputted lines count of a context
 `.win_cursor_linenr_highlight` | Funcref to open a new window with search results
 -----------------------------+-------------------------------------------------

g:esearch.win_new                                              *g:esearch.win_new*
        Specifies a function to open a new search window
        Type: |Funcref|
        Default: a function, that reuse windows with the same search patterns.
        Example:~
        >
        let g:esearch.win_new = {-> esearch#buf#goto_or_open('[Search]', 'vnew')}
<
        Example above will use a single window for any search request in a
        vertical split and reuse it for further searches.

g:esearch.win_contexts_syntax                      *g:esearch.win_contexts_syntax*
        Toggles filetype-dependent syntax.
        Type: |Boolean|
        Allowed values: 1 or 0.
        Default: 1
        Example:~
        >
        let g:esearch.win_new = 1
<
g:esearch.win_map                                              *g:esearch.win_map*
        Allows to define search window-local mappings. Contains maparg dicts
        that define mappings. See :help |maparg()| for details. As an
        alternative, |esearch_win_config| autocommand can be used.
        for details
        Type: |List| of |Dict|s
        Default: see |vim-esearch-win-map-defaults|
        Example:~
>
        let g:esearch.win_map = []
        let g:esearch.win_map += {'lhs': 'e': 'rhs': '<plug>(esearch-win-open)'}
<
        See also: |vim-esearch-win-map|

g:esearch.win_context_len_annotations      *g:esearch.win_context_len_annotations*
        Toggles annotations to the right of a filename, that show the number
        of outputted lines.
        Type: |Boolean|
        Allowed values: 1 or 0.
        Default: 1
        Example:~
        >
        let g:esearch.win_context_len_annotations = 1
<
        NOTE: neovim 0.4.3 or higher is required.

g:esearch.win_cursor_linenr_highlight      *g:esearch.win_cursor_linenr_highlight*
        Toggles cursor line numbers highlight, like it's done in regular
        buffers.
        Type: |Boolean|
        Default: depends on 'cursorline' vim's option value.
        Example:~
        >
        let g:esearch.win_cursor_linenr_highlight = 1
<

________________________________________________________________________________~
SEARCH WINDOW PREVIEW                                   *vim-esearch-win-preview*
                                                  *vim-esearch-win-split-preview*

The plugin has two option for previewing the results:
- floating preview (using neovim floating windows).
- split preview (using a regular split window).

Preview window is opened with `p` key or using |<plug>(esearch-win-preview)|
key is remapped. For neovim floating window is used. For regular vim split
preview will be used. To zoom preview window press `p` key multiple times.
Preview window can be entered by pressing capital `P`. Use
|<plug>(esearch-win-preview:enter)| to map a custom key to enter the preview
window.

See also: |vim-esearch-map| for mappings customization.

________________________________________________________________________________~
APPEARANCE                                                *vim-esearch-appearance*

Search window outlook:

            esearchHeader
  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
             +--------+--------------------- esearchStatistics
             v        v
  Matches in 2 lines, 1 file. Finished.

 +>   /path/to/file.txt 2 lines <------------ Annotation {2}
 |  +> 1 `matched text`
 |  |  `2` another |line with `matched text`
 |  |  ^         ^          ^^^^^^^^^^^^
 |  |  |         |          esearchMatch
 |  |  |         Cursor position {1}
 |  |  esearchCursorLineNr
 |  esearchLineNr
esearchFilename
                                   {1} Vim cursor position
                                   {2} See |g:esearch.win_context_len_annotations|

Example:
>
  highlight      esearchHeader     cterm=bold gui=bold ctermfg=white ctermbg=white
  highlight link esearchStatistics esearchFilename
  highlight link esearchFilename   Label
  highlight      esearchMatch      ctermbg=27 ctermfg=15 guibg='#005FFF' guifg='#FFFFFF'
<

esearchHeader                                                   *hl-esearchHeader*
        First window line highlight. Contains statistics, spinner and request
        status information.
        Default: linked to |hl-Title|

esearchStatistics                                           *hl-esearchStatistics*
        Highlights information about outputted lines and files count.
        Contained in the header.
        Default: linked to |hl-Number|

esearchFilename                                               *hl-esearchFilename*
        Filename above each context.
        Default: linked to |hl-Directory|

esearchLineNr                                                   *hl-esearchLineNr*
        Virtual UI line number highlight.
        Default: linked to |hl-LineNr|

esearchCursorLineNr                                       *hl-esearchCursorLineNr*
        Virtual UI line number highlight when the cursor is on the line TODO
        Default: linked to |hl-CursorLineNr|

esearchMatch                                                     *hl-esearchMatch*
        Matched text highlight.
        Default: guessed using |hl-Normal| color.

________________________________________________________________________________~
PERFORMANCE                                              *vim-esearch-performance*

Performance configurations:

                 Property                                     Comment~
 ------------------------------------------+------------------------------------------------------
 `.win_update_throttle_wait`                 | Update throttling timeout
 `.win_matches_highlight_debounce_wait`      | Viewport matches highlight debouncing timeout
 `.win_contexts_syntax_debounce_wait`        | Viewport filetypes highlight debouncing timeout
 `.win_viewport_off_screen_margin`           | Controls the height of viewport
 `.win_matches_highlight_strategy`           | A strategy to highlight matched text
 `.win_contexts_syntax_sync_minlines`        | See :help |:syn-sync-minlines| for details
 `.win_context_syntax_clear_on_line_len`     | Max line len before a filetype syntax is cleared
 `.win_contexts_syntax_clear_on_line_len`    | Max line len before all syntaxes are cleared
 `.win_contexts_syntax_clear_on_files_count` | Max files count before filetype syntaxes are cleared
 `.win_ui_nvim_syntax`                       | Use position based syntax with (neovim only)
 ------------------------------------------+------------------------------------------------------

Example configuration to make window as fast as possible:
>
    let g:esearch.win_update_throttle_wait            = 200
    let g:esearch.win_matches_highlight_strategy      =
      \ g:esearch#has#nvim_lua_syntax ? 'viewport' : 'hlsearch'
    let g:esearch.win_matches_highlight_debounce_wait = 200
    let g:esearch.win_viewport_off_screen_margin      = 0

    " Disable filetype-dependent syntaxes
    let g:esearch.win_contexts_syntax = 0
    " or make them faster
    let g:esearch.win_contexts_syntax_sync_minlines        = 100
    let g:esearch.win_context_syntax_clear_on_line_len     = 200
    let g:esearch.win_contexts_syntax_clear_on_line_len    = 100
    let g:esearch.win_contexts_syntax_clear_on_files_count = 100
    let g:esearch.win_ui_nvim_syntax                       = 1
<
g:esearch.win_update_throttle_wait            *g:esearch.win_update_throttle_wait*
        Window updates timeout. The bigger this value, the lower slowdowns,
        but also the later the search finish.
        Type: |Number|
        Allowed value: >= 0.
        Default: 100.

                                   *g:esearch.win_matches_highlight_debounce_wait*
g:esearch.win_matches_highlight_debounce_wait
        Debounce (trailing edge) timeout, used to prevent slowdowns on scrolls.
        Type: |Number|
        Allowed value: >= 0.
        Default: 100.

        NOTE Has no affect unless |g:esearch.win_matches_highlight_strategy| is not
        "viewport".

                                     *g:esearch.win_contexts_syntax_debounce_wait*
g:esearch.win_contexts_syntax_debounce_wait
        Debounce (trailing edge) timeout, used to prevent slowdowns on
        scrolls, caused by loading filetype-dependent context syntaxes.
        Type: |Number|
        Allowed value: >= 0.
        Default: 100.

        NOTE Has no affect unless |g:esearch.win_contexts_syntax| is not 1.

                                        *g:esearch.win_viewport_off_screen_margin*
g:esearch.win_viewport_off_screen_margin 
        A number of lines, used to prevent slowdowns caused by viewport
        position based matches highlights adding or filetype-dependent context
        syntaxes loading when |CTRL-D| or |CTRL-U| scrolling is used.
        Type: |Number|
        Allowed value: >= 0.
        Default: depends on 'lines' option, but always >= 100.

        NOTE Has no affect unless |g:esearch.win_contexts_syntax| is not 1 or
        |g:esearch.win_matches_highlight_strategy| is not "viewport".

                                        *g:esearch.win_matches_highlight_strategy*
g:esearch.win_matches_highlight_strategy
        A strategy to highlight matched text. Viewport highlight strategy use
        neovim position based highlights and is the fastest. Hlsearch strategy
        highlights matches by overwriting |@/| search register. Matchadd
        strategy use |matchadd()| function and can be slow when the output is
        big.
        Type: |Number|
        Allowed value: 'viewport', 'hlsearch' or 'matchadd'.
        Default: 'viewport' if g:esearch#has#nvim_lua_syntax is true,
        'matchadd' otherwise.

                                     *g:esearch.win_contexts_syntax_sync_minlines*
g:esearch.win_contexts_syntax_sync_minlines
        See :help |:syn-sync-minlines| for details
        Type: |Number|
        Allowed value: > 0.
        Default: 500

        NOTE Has no affect unless |g:esearch.win_contexts_syntax| is not 1.

                                  *g:esearch.win_context_syntax_clear_on_line_len*
g:esearch.win_context_syntax_clear_on_line_len
        Is used to set line length limit, after which a context syntax will be
        disabled to prevent slowdowns (vim regex-based syntax peculiarity).
        Allowed value: > 0.
        Default: 800.

                                 *g:esearch.win_contexts_syntax_clear_on_line_len*
g:esearch.win_contexts_syntax_clear_on_line_len
        Is used to set line length limit, after which all filetype-dependent
        syntaxes will be disabled to prevent slowdowns (vim regex-based
        syntax peculiarity). Is relevant when one-line files like minified svg,
        js or css are outputted.
        Type: |Number|
        Allowed value: > 0.
        Default: 30000.

                              *g:esearch.win_contexts_syntax_clear_on_files_count*
g:esearch.win_contexts_syntax_clear_on_files_count
        Is used to set line files count limit, after which all filetype-dependent
        syntaxes will be disabled to prevent slowdowns (vim regex-based
        syntax peculiarity).
        Type: |Number|
        Allowed value: > 0.
        Default: 800 if |g:esearch.win_matches_highlight_strategy| is
        'viewport', 200 otherwise.

g:esearch.win_ui_nvim_syntax                        *g:esearch.win_ui_nvim_syntax*
        Use position-based syntax to highlight virtual UI elements. Is faster
        than using vim regex-based syntax highlights.
        Type: |Boolean|
        Allowed value: 1 or 0.
        Default: depends on g:esearch#has#nvim_lua_syntax.
================================================================================
COMMANDLINE                                                  *vim-esearch-cmdline*

COMMANDLINE INPUT PROMPT                              *vim-esearch-cmdline-prompt*

Input prompt is opened when <plug>(esearch) or <plug>(esearch-prefill) are
pressed.

Within the prompt matching modes can be changed by double clicking:
- <c-r><c-r> toggles regex mode.
- <c-s><c-s> toggles case sensitive mode
- <c-t><c-t> toggle textobj matching mode.

NOTE Double clicks are used to prevent any conflicts with the default mappings
(e.g. |c_CTRL-R| to insert the contents of a register). TODO

Press <c-o> to open the menu to configure search paths, filetypes and other
options.

________________________________________________________________________________~
COMMANDLINE MENU                                        *vim-esearch-cmdline-menu*

Menu is a commandline-based way to configure the values, stored in |g:esearch|
on the fly. It's separated into 4 columns: keys, that are used to activate
corresponding menu items, icons, to hint what item is active or not, a
column with a short comments and greyed-out text, that shows options to be
used in the command.

When within the search prompt, type <c-o> to open the menu.
Use `j` and `k` to navigate the menu items and <enter> key to active an item.
If the item is numeric you can use `0`-`9` keys to configure the value or
<bs> to set it to 0.
Use <esc> or <c-c> keys to close the menu and continue typing the search
pattern.

================================================================================
API                                                              *vim-esearch-api*

API is a set of global functions and |b:esearch| scoped methods to customize
the workflow. See |vim-esearch-api-examples| to view what can be done by using the
API.

API GLOBAL FUNCTIONS                            *vim-esearch-api-global-functions*

esearch#init([{options}])                                         *esearch#init()*
        Is invoked when |<plug>(esearch)| map is triggered.

        Parameters: ~
            {options} Dict with the same key-values as for |g:esearch| dict to
                      overrule it (optional).
        Return: ~
            0
        Example:
>
        nnoremap <leader>fs :call esearch#init({
            \ 'paths': $GOPATH . ' node_modules/',
            \ 'remember': ['regex', 'case']
            \})<cr>
<
        Will search in vendor lib directories. Remembers only 'regex' and 'case'
        modes if they are changed during a request.
        
        See also: |g:esearch.remember|, |g:esearch.paths|

esearch#debounce({func}, {wait}, [{options}])                 *esearch#debounce()*
        Can be used to create events independently from |CursorHold|. At the
        moment only trailing edge debouncing is supported.

        Parameters: ~
            {func}    Funcref to call on timeout.
            {wait}    Wait timeout in milliseconds.
        Return: ~
            Dict with `.apply()` and `.cancel()` method to invoke the
            debounced function or to cancel it's invocation before {wait}
            timeout is exceeded.
        Example:
        >
        let g:preview_on_hover = esearch#debounce({-> b:esearch.preview()}, 1000)
        au User esearch_win_config
              \ au CursorMoved <buffer> call g:preview_on_hover.apply()
<
        It creates `g:preview_on_hover` decorated method to show the preview
        at the cursor position when the cursor is above a line longer than 1000
        milliseconds.

        See also: |esearch_win_config| event, |b:esearch.preview()| method

________________________________________________________________________________~
API LOCAL FUNCTIONS                              *vim-esearch-api-local-functions*

                                           *b:esearch.open()* *b:esearch.filename()*
                             *b:esearch.unescaped_filename()* *b:esearch.filetype()*
                                    *b:esearch.line_in_file()* *b:esearch.preview()*
                              *b:esearch.preview_zoom()* *b:esearch.preview_enter()*
                           *b:esearch.preview_close()* *b:esearch.is_preview_open()*
                                *b:esearch.split_preview()* *b:esearch.jump2entry()*
                               *b:esearch.jump2filename()* *b:esearch.is_filename()*
                                     *b:esearch.is_entry()* *b:esearch.is_current()*
                                                            *b:esearch.is_blank()*

|b:esearch| contains options, inherited from |g:esearch| and methods to interact
with the search window.

      Method                                    Comment~
 ----------------------+---------------------------------------------------------------------
 `.open()`               | Open a line under the cursor. Used by `o`, `s`, `t`, <cr> and other mappings
 `.filename()`           | Return escaped entry filename under the cursor
 `.unescaped_filename()` | Return unescaped entry filename under the cursor
 `.filetype()`           | Return a filetype under the cursor
 `.line_in_file()`       | Return line number in a file for entry under the cursor
 `.preview()`            | Open the preview window
 `.preview_zoom()`       | Increase preview window height. Used in |<plug>(esearch-win-preview)|
 `.preview_enter()`      | Open the preview window. Used in |<plug>(esearch-win-preview:enter)|
 `.preview_close()`      | Close the preview window
 `.is_preview_open()`    | Check if the preview is opened
 `.split_preview()`      | Open split preview window. A wrapper around |b:esearch.open|
 `.jump2entry()`         | Move the cursor to the next/prev entry
 `.jump2filename()`      | Move the cursor to the next/prev filename
 `.is_filename()`        | Return true if the cursor is above a filename
 `.is_entry()`           | Return true if the cursor is above an entry
 `.is_current()`         | Return true if the window related to |b:esearch| is current
 `.is_blank()`           | Return if a search request outputted no results.
 ----------------------+---------------------------------------------------------------------

________________________________________________________________________________~
API EVENTS                                                *vim-esearch-api-events*
                                         *eseach_init_pre* *eseach_config_eager_pre*
                                   *eseach_config_eager_post* *esearch_win_init_pre*
                                     *esearch_win_uninit_pre* *esearch_win_init_post*
                                                              *esearch_win_config*

Events in the order they are fired:

          Event                                 Comment~
 -------------------------+-----------------------------------------------------
 `eseach_init_pre`          | Before |esearch#init| execution
 `eseach_config_eager_pre`  | Once before lazy configurations are loaded
 `eseach_config_eager_post` | Once after lazy configurations are loaded
 `esearch_win_init_pre`     | Before the search window is initialized
 `esearch_win_uninit_pre`   | Before the cleanup from the previous search
 `esearch_win_init_pre`     | Before the search window is initialized
 |FileType| esearch         | Builtin event. Use |esearch_win_config| instead
 `esearch_win_config`       | Should be used to configure the window
 `esearch_win_init_post`    | After the search window is initialized
 -------------------------+-----------------------------------------------------

Example:
>
    autocmd User esearch_win_config set nowrap
<
NOTE |esearch_win_config| is preferred over |FileType| esearch event as it's
designed to automatically cleanup events on window reloading or window reusing
and will prevent the window from autocommands bloat. If you still prefer using
|FileType| event, wrap it in |esearch_win_config| augroup (it shares the same name
as the event for simplicity).

________________________________________________________________________________~
API USAGE EXAMPLES                                      *vim-esearch-api-examples*

                                                         *esearch#init()-examples*
Search for debugger entries across the project without starting the prompt.
Remember is set to 0 to prevent saving configs history for later searches.
>
    nnoremap <leader>fd :call esearch#init({
        \ 'pattern': '\b(ipdb\|debugger)\b',
        \ 'regex':    1,
        \ 'remember': 0
        \})<cr>
<
Search in vendor lib directories. Remember only `'regex'` and `'case'` modes if
they are changed during a request.
>
    nnoremap <leader>fs :call esearch#init({
        \ 'paths':    $GOPATH . ' node_modules/',
        \ 'remember': ['regex', 'case']
        \})<cr>
<
Search in front-end files using an explicitly set cwd.
>
    nnoremap <leader>fe :call esearch#init({
        \ 'paths': '**/*.{js,css,html}',
        \ 'cwd':   '~/other-dir'
        \})<cr>
<
If one of ag, rg or ack is available
>
    nnoremap <leader>fe :call esearch#init({
        \ 'filetypes': 'js css html',
        \ 'cwd': '~/another-dir'
        \})<cr>
<
Use callable pre-filler to search go functions. Starting cursor position will
be before the closing bracket.
>
    let g:search_gofunc = {
        \ 'prefill':          [{-> "func (\<Left>"}],
        \ 'filetypes':       'go',
        \ 'select_prefilled': 0
        \}
    nnoremap <leader>fu :call esearch#init(g:search_gofunc)<cr>
<
NOTE `\<left>` syntax usage to move the cursor around. You can also use other
bracketed keys to define the initial cursor position. The following example
helps to search lines that end with ; by pre-filling the prompt with `|.*;$`,
where `|` is the cursor position.
>
    let g:colon_ended_lines = {'prefill': [{-> ".*;$\<home>"}], 'regex': 1'}
    nnoremap <leader>f; :call esearch#init(g:colon_ended_lines)<cr>
<
                                                     *esearch_win_config-examples*
                                                              *b:esearch-examples*

Use `esearch_win_hook` to setup window local configurations.
NOTE It'll automatically wrap `s:custom_esearch_config()` call to collect garbage on
reloads, so no `augroup` inside is required.
>
    autocmd User esearch_win_config call s:custom_esearch_config()

    function! s:custom_esearch_config() abort
      setlocal nobuflisted    " to not show the buffer in the buffers list
      setlocal bufhidden=hide " to be able to use <c-o> jumps

      " Override the default vertical split mapping to open a split once and
      " reuse it for later `s` presses. The search window will remain focused
      nnoremap <silent><buffer> s  :call b:esearch.open('vnew', {
          \ 'reuse': 1,
          \ 'stay': 1})<CR>
      " Yank a hovered absolute path
      nnoremap <silent><buffer> yy :let @" = b:esearch.filename()\|let @+ = @"<CR>
      " Use a custom command to open a file in a tab
      nnoremap <silent><buffer> t  :call b:esearch.open('NewTabdrop')<CR>

      " Populate the quickfix list using the current pattern
      nnoremap <silent><buffer> <leader>fq :call esearch#init({
          \ 'pattern': b:esearch.pattern,
          \ 'out': 'qflist',
          \ 'remember': 0})<CR>
    endfunction
<
                                                    *b:esearch.preview()-examples*
                                                         *vim-esearch-autopreview*

Show the preview automatically and update it after 100ms timeout. Change
'vsplit' to 'split' to open the preview horizontally.
>
    autocmd User esearch_win_config
      \   let b:autopreview = esearch#debounce(b:esearch.split_preview, 100)
      \ | autocmd CursorMoved <buffer> call b:autopreview.apply('vsplit')
<
                                          *vim-esearch-offscreen-filename-example*

The example below will show context filenames in 'statusline' that are outside
(above) the viewport.
>
    function! s:offscreen_filename() abort
      if exists('b:saved_statusline')
        let  &statusline = b:saved_statusline
        unlet b:saved_statusline
      endif

      let top_line = line('w0')

      if b:esearch.filename() ==# b:esearch.filename(top_line)
            \ && b:esearch.is_entry(top_line)
        let b:saved_statusline = &statusline
        set statusline=%#esearchFilename#%{b:esearch.filename()}
      endif
    endfunction

    let s:show_offscreen_filename =
        \ esearch#debounce(function('s:offscreen_filename'), 49)
    au User esearch_win_config
        \ au CursorMoved <buffer> call s:show_offscreen_filename.apply()
<
________________________________________________________________________________~
TROUBLESHOOTING                                      *vim-esearch-troubleshooting*

1. Show previews automatically on cursor movement.

See |vim-esearch-autopreview|.

2. Avoid searching in `log/`, `node_modules/`, `dist/` and similar folders.

The preferred approach is to use `.agignore` for ag, `.rgignore` or similar
ignore files. To skip `node_modules` try `echo node_modules >> ~/.ignore`.

3. Git adapter have problems when searching in filenames with non-ASCII names.

Run in your shell to prevent outputting unicode chars like `\312`.
>
    git config --global core.precomposeunicode true
    git config --global core.quotePath false
<
4. Some regex features like lookaround are not supported.

Use ag, ack or rg (after version 0.11) to access the PCRE syntax. Git and grep
are also support them, but sometimes require to be installed with the
corresponding flag.

5. Filetype-specific syntax highlights are missing or different than those
within opened files.

The plugin uses separate syntax definitions to make the window more
lightweight.  If it's misleading for you, please, disable them using `let
g:esearch.win_contexts_syntax = 0` or open a PR to add or improve the existing
syntax files. Highlights can also be cleared automatically if there are too
many lines or if there's a long line encountered.

6. The search window is slow.

If it's sluggish during updates, try to increase `let
g:esearch.win_update_throttle_wait = 200` value (100 is the default). If it's
still slow after the search has finished, try to use `let
g:esearch.win_contexts_syntax = 0` or consider to use neovim, as it has
position-based highlights comparing to regex-based syntax matches and
parses/renders results faster. Also, make sure that `echo esearch#has#lua`
outputs 1.

7. Pt adapter case-insensitive mode implicitly enables regex matching mode.

Ignore case option in `pt` works by building a regex so you should use case
sensitive mode to match literally or switch to another adapter like `ag` or
`rg`.

================================================================================
ABOUT                                   *vim-esearch-about*

The latest version is available at:
https://github.com/eugen0329/vim-esearch

vim:tw=80:cole=2:et:ft=help:norl:
